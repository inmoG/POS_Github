# 문자를 저장하는 변수

```C
#include <stdio.h>
int main()
  char a;
  a = 'a'
  printf("a의 값과 들어있는 문자는? %d %c\n",a, a);
  return 0;

```

위 코드를 실행하면 숫자 97과 문자 'a' 가 출력된다.

왜 이런 결과가 나오는걸까?

`%d`는 `a`의 값을 숫자로 출력하라, `%c`는 `a`의 값을 문자로 출력하라는 의미다.

컴퓨터는 문자와 숫자를 일대일 대응 시켜서 생각한다. 따라서 `%d`에 출력되는 숫자는 `a`에 대응되는 숫자이다.
각 문자는 대응되는 숫자가 정해져있고 그 내용은 `아스키코드`라고 불린다.

![아스키코드.png](https://images.velog.io/post-images/jjewqm/ede91e20-46ee-11ea-a334-95705e7d6ce1/아스키코드.png)

위 표가 ASCII 코드로 8 비트 데이터를 이용해 여러 문자에 번호를 붙인 것이다.
표에서 문자 `a`를 찾아보면 10진수 97이 정의되어 있는 걸 알 수 있다.

# scanf

```c
float a;
scanf('%f', &a);
```

`scanf('형식 지정자', &변수명)` 형식을 사용하며
`scanf`는 값을 입력받는 `입력 함수`이다.
`출력 함수`인 `printf`처럼 변수의 타입마다 입력받는 `형식 지정자`가 다르다.
`char`자료형은 1바이트를 저장할 수 있어 저장 범위를 초과하면 허용된 메모리 저장범위를 넘어 `buffer Overflow`가 발생한다.
그래서 `char 변수명[256]`으로 `문자열`을 저장해야 한다. 이 역시 저장 범위를 넘어서면 `buffer Overflow`가 발생한다.

| 자료형    | 형식 지정자 |
| --------- | ----------- |
| int       | %d          |
| short     | %hd         |
| long      | %ld         |
| float     | %f          |
| double    | %lf         |
| char      | %c          |
| char[256] | %s          |

그리고 scanf 보다 scanf_s 를 사용이 권고된다. 그 이유는 scanf 가 입력받는 데이터의 크기를 확인하지 않기 때문에 버퍼 오버플로우 (입력받는 데이터의 크기가 준비된 공간보다 큰 문제) 가 발생할 수 있기 때문이다.

# reference

본 글은 이재범님의 모두의 코드 강좌를 정리합니다.
https://modoocode.com/9
