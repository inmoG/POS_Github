# 메모리 구조

머신 코드 영역에는 프로그램이 실행될 때 그 프로그램이 컴파일된 바이너리가 저장된다.
글로벌 영역에는 프로그램 안에서 저장된 전역 변수가 저장된다.
힙 영역에는 malloc으로 할당된 메모리 데이터가 저장된다.
스택에는 프로그램 내 함수와 관련된 것들이 저장된다.

힙 영역은 **malloc에 의해 메모리가 더 할당될수록,** 점점 사용하는 메모리 범위가 **아래로 늘어난다.**
스택 영역은 **함수가 더 많이 호출 될수록** 사용하는 메모라 범위가 점점 **위로 늘어난다.** 힙과 스택이 점점 커지다 보면 제한된 메모리 용량 하에서 기존 값을 침범하는 상황이 발생한다. 이러한 현상을 힙 오버플로우 또는 스택 오버플로우라고 부른다.

## 정수 입력 받기

```c
#include <stdio.h>

int main(void)
{
    int x;
    printf("x: ");
    scanf("%d", &x);
    printf("x: %d\n", x);
}
```

scanf함수는 사용자가 숫자를 입력하고 엔터를 누르면 x의 주소에 숫자를 저장한다. scanf와 같은 함수를 부를 때 변수 주소를 scanf에게 주는 이유는 swap함수와 같다. 변수 값을 바꾸려고 사용자 함수 또는 라이브러리 함수를 사용할 때 값으로 전달하면 안 된다. 그러면 단순히 **값을** 복사해 전달하고 스택을 벗어나면 사라진다. 따라서 함수 스택에서 벗어나 변수에 변경할 값을 전달하려면 `&x`를 사용해 주소를 전달해야 한다. 그래야 swap, scanf 같은 함수가 그 주소로 찾아가 값을 저장할 수 있다.

## 문자열 입력 받기

```c
#include <stdio.h>

int main(void)
{
    char s[5];
    printf("s: ");
    scanf("%s", s);
    printf("s: %s\n", s);
}
```

문자열을 입력받을 때는 scanf함수에게 주소를 전달하지 않는다. char 변수를 크기가 5인 문자열, 즉 char 자료형 배열로 정의하였다. 배열은 메모리가 연속적으로 할당된 공간이며 문자열은 문자가 연속적으로 있다. 따라서 문자열은 배열의 메모리 공간 첫 번째 주소를 의미한다. 컴파일러는 **"문자 배열 이름을 포인터처럼"** 다룬다. 그래서 scanf는 배열 첫 바이트 주소를 알고 있어서 s 배열 첫 바이트 주소로 입력 받은 값을 전달한다.

### 파일 쓰기

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>

int main(void)
{
    FILE *file = fopen("phonebook.nsv", "a");
    // a : 읽기, w : 쓰기, a : 덧붙이기

    char name[7];
    scanf_s("%s\n", name, sizeof(name));

    char number[3];
    scanf_s("%s\n", number, sizeof(number));

    fprintf(file, "%s,%s\n", name, number);
    fclose(file);
}
```

fopen함수를 이용하면 파일을 FILE 자료형으로 불러올 수 있다. fopen함수 첫번째 인자는 파일 이름, 두번째 인자는 모드로 r은 읽기, w는 쓰기, a는 덧붙이기를 의미한다.

사용자에게 문자열 입력 받고 fprintf함수를 이용해 파일에 직접 내용을 출력할 수 있다. 작업이 끝나면 fclose함수로 파일 작업을 종료한다.
