# SQL Injection
<br></br>

# 개념 
-SQL Injection이란 의적인 사용자가 보안상의 취약점을 이용하여, 임의의 SQL 문을 주입하고 실행되게 하여 데이터베이스가 비정상적인 동작을 하도록 조작하는 행위이다.<br></br>

# SQL의 동작 방식
1. 사용자가 입력한 값이 $id 변수로 입력된다.
2. 입력된 $id 변수는 사용자의 이름과 성을 조회하는 SQL문에서 사용자를 구분하는 변수로 사용된다.(user_id의 값) 이러한 SQL 문은 $query 변수에 저장된다.
3. $query 변수는 MySQLi_query() 함수를 통해 데이터베이스에 쿼리 문자열로 전송되며 결과는 $result에 저장된다.
4. MySQLi_query()를 통해 얻은 $result 변수는 $query의 실행결과를 가지고 있으며, while 문과 MySQLi_fetch_assoc() 함수를 통해 레코드를 1개씩 반환받은 후 데이터베이스 내의 first_name과 last_name을 각각 $first와 $last 변수에 저장한다.
5. 마지막으로 echo문을 통해 $id, $first, $last 값을 웹 페이지에 출력한다.</br></br><br></br>

# SQL Injection 공격 원리
-소스코드 내 $query 변수는 위에서 언급한 바와 같이 실제로 데이터베이스에 내부 데이터 처리를 요청하는 구문이 들어있다. 그중에서도 다른 값들은 자체적으로 미리 정의되어 있으나, 변경이 가능한 $id 변수에 주목하자. $id는 실제 사용자가 입력한 값이 저장되는 변수이고며, 이를 악용하여 SQL Injection 공격을 진행할 수 있다.
<br></br><br></br>
# LOW 레벨
*1) 특정 사용자 이름 확인*<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMjQz/MDAxNTk4NTgzODgyMDk4.MbiuhRJQWK6UXA9QJKqmYbQiCgixXcniCJMGMYBpt9wg.pjS9m0QWr4L-BtjxuyxHm71VQbZRoGdmtQ_57ILQsMYg.PNG.depeix/%EC%BA%A1%EC%B2%98.PNG?type=w773)<br></br>
1을 입력하게 될 시 ID가 1인 사용자의 정보가 화면에 출력되는 것을 볼 수 있다. 데이터베이스는 `USER ID`에 해당하는 정보를 찾아온다고 추정할 수 있다.<br></br><br></br>
*2) 전체 사용자 정보 확인*<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfNTMg/MDAxNTk4NTgzODg3MzU3.lr3bcUY1EG2f9RIu2nOH-8gK_ktdb0RWagI2dJkncV0g.lKmcksJdgabmkRzRla6b5L0f4p52epMbAbHtir212v4g.PNG.depeix/%EC%BA%A1%EC%B2%981.PNG?type=w773)<br></br>
99‘ or ’1’=’1을 입력하게 될시 서버에 요청값은 SELECT first_name, last_name FROM users WHERE user_id = '99' or '1'='1'가 되고 id가 99인 사용자가 없더라도 1=1이 항상 참이 됨으로 모든 사용자의 정보를 얻을 수 있게 된다.<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMTY1/MDAxNTk4NTgzODkyNTA5.X71wXW3oZRY3Byjw8ZlQ85i8fs4fv7uKC6N1sqb7HjYg.1DBL3oFRwfE6Csqmr_AIuNiIS6MHOu7aU4U5aQrXUqIg.PNG.depeix/%EC%BA%A1%EC%B2%982.PNG?type=w773)<br></br>
‘ or ’1’=’1’ #를 입력해도 이전의 99‘ or ’1’=’1와 같이 데이터베이스 내 전체 사용자의 정보가 출력된다. # 문자는 주석을 의미함으로 # 뒤에 오는 SQL 쿼리는 주석처리 되어 where 조건문이 실행되지 않는다.<br></br><br></br>
*3) 데이터베이스 버전 및 호스트 명 확인*
-Union 구문
union을 사용하기 위해서는 원래 SQL 쿼리문이 조회하는 select문의 컬럼 개수와 union 뒤의 select 구문의 컬럼 개수가 같아야 한다. 따라서 union 구문을 사용하기 위해서는 원래 SQL 쿼리문이 몇 개의 컬럼을 가지고 있는지 확인해야 한다.<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMTI5/MDAxNTk4NTgzOTAwMDU1.9H7m0do1GPmVMM4qdzqCIdWOSaZ47gRxDuZ0O3tgqOMg.tr6YjPf9mg1MWasjSQtcsxcZ0xO0TgY-3QNEcD2o1Rsg.PNG.depeix/%EC%BA%A1%EC%B2%983.PNG?type=w773)<br></br>
MySQL 데이터베이스의 버전을 알려주는 함수인 @@version을 사용해 ‘union select @@version#을 입력하면 저런 오류 메시지가 뜨게되는데 요청한 SQL 쿼리와 데이터베이스 컬럼의 개수가 맞지 않는다는 정보를 확인함으로써 select 뒤의 컬럼 수는 1개이지만 실제로는 그 이상으로 해석할 수 있다.<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMTYz/MDAxNTk4NTgzOTAyODEw.mhpP2LYDV1UIVYzq1oymyCPYDhE9ZyMaOUN9phmo33Eg.ZlFbdyUlmiU7ijWbs6rMFwhN3NJ_V5DC41fN8Y-kDzIg.PNG.depeix/%EC%BA%A1%EC%B2%984.PNG?type=w773)<br></br>
UNION 연산자를 사용하여 select 뒤에 아무 문자나 넣어서 컬럼 개수를 맞춰주고, @@version을 입력하면 데이터베이스 버전이 출력되는 것을 확인 할 수 있다.<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMzgg/MDAxNTk4NTgzOTA1NDgw.tk9PwJbbY5Yi_ZSZUjgeixWWhgSChoOzqDvGcIkbrAgg.eRNgCVJnpLVTXofD7wKIH8sJpmhzikhoqW6npEulTK0g.PNG.depeix/%EC%BA%A1%EC%B2%985.PNG?type=w773)<br></br>
@@hostname을 입력하면 서버의 호스트 이름을 확인 할 수 있다.
<br></br><br></br>
*4) 필드 개수 확인*<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMjYw/MDAxNTk4NTgzOTA4MTEz.t252tK4TH4CIZpSwu-CnBiVExW3IZWwo5NZSnUrCo6wg.fJFloksfEeKQDZBfd8-pocTR3dFIba09NvZj3KNeoGkg.PNG.depeix/%EC%BA%A1%EC%B2%986.PNG?type=w773)<br></br>
필드 개수를 확인하기 위해 SQL 쿼리에서 ’order by’라는 정렬 함수를 사용한다.
그런데 오류가 생기는걸 볼 수 있다. ‘order by 3#’이 오류가 난다는 것은 필드의 개수가 3개 이하라는 의미가 됨으로 ‘order by 2#’로 입력시 다음과 같이 정상적으로 응답하는 것을 알 수 있다.<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMTI3/MDAxNTk4NTgzOTExMDY4.8XxM4RRg3l7r9oJdFHlpH-lsA2Kys0ZEVpl3f9fXO4Mg.Cp9GrurLKyd9A5fIsJtHP9QWjxIorhAsT3mEUVRD_28g.PNG.depeix/%EC%BA%A1%EC%B2%987.PNG?type=w773)<br></br><br></br>
*5) 시스템 사용자 확인*<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMTEy/MDAxNTk4NTgzOTE0NTYx.A72JsE0zszN7PmD7hirt08d0yb1tr2syySNedDhyQckg.f1fItIvvcjeN-ncznT8D5-kLvQLpI5pcGAvd4w2hgcUg.PNG.depeix/%EC%BA%A1%EC%B2%988.PNG?type=w773)<br></br>
system_user(), user() 함수를 이용하여 구동중인 데이터베이스와 어떤 권한을 가지고 있는지 확인 할 수 있다.<br></br><br></br>

*6) 현재 데이터베이스명 확인*<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfODkg/MDAxNTk4NTgzOTE3NTg3.mtCLsWPS4cCUCKvuhYux37uYPvhOTBvPLAl-5e6sG2cg.rmqckTclxHv9yqhrr5fBW5iwbWxj7ibAdxHAorAeYS8g.PNG.depeix/%EC%BA%A1%EC%B2%989.PNG?type=w773)<br></br>
database() 함수를 이용하여 현재 웹 페이지와 연결된 데이터베이스 확인이 가능하다. SQL 인젝션 공격 결과 사용중인 데이터베이스명은 ‘dvwa’ 임을 알 수 있다.<br></br><br></br>

*7) MySQL 내 존재하는 데이터베이스 확인*<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMiAg/MDAxNTk4NTgzOTIwNTA3.33s9X67lrvkwB26yOWA5pU0OfIcJv19XKelmdOucoOkg.0isqUoc9d7vqgNvzr_Ts8Vv1i7NcOlb5cJR_qY5nyqgg.PNG.depeix/%EC%BA%A1%EC%B2%9810.PNG?type=w773)<br></br>
information_schema를 통해 MySQL 내 존재하는 데이터베이스를 확인할 수 있다.<br></br><br></br>

*8) DVWA 내에 있는 테이블 확인*<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMTcx/MDAxNTk4NTgzOTIzNjE2.BzQy1l6z_yllArXmYlfmLv_2O22e7toYlreuOlVviF8g.py1iOHXsKdVVeWhgKO5nmIinxgpZqxnyECr9rkWpoVgg.PNG.depeix/%EC%BA%A1%EC%B2%9811.PNG?type=w773)<br></br>
데이터베이스 목록을 확인했으니 공격 대상의 데이터베이스에 대한 세부정보를 확인한다.
table_name에서 user_id, password 컬럼을 확인할 수 있다.
<br></br><br></br>
*9) 테이블 구조(열) 확인*<br></br>
users 테이블의 컬럼 이름을 확인해보자<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMjEx/MDAxNTk4NTgzOTI2NjUy.nE8BXn8WhDBFDlHVMQJmEMM_FsJ0E9NWKqsPI_JZZ_kg.hDz8skDYvNoXpO_h3GNoYehm51Z16ExqcFMUo882OKog.PNG.depeix/%EC%BA%A1%EC%B2%9812.PNG?type=w773)<br></br>
users 테이블 내의 컬럼 이름들이다.<br></br><br></br>

*10) 사용자명과 패스워드 확인*<br></br>
이전 공격을 통해 users 테이블에 password 컬럼이 있다는 것을 알게 되었다. password 컬럼을 조회하여 해쉬 값으로 이루어진 것으로 추정되는 각 사용자의 패스워드 조회가 가능하다.<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMTA4/MDAxNTk4NTgzOTI5Njgy.Jj5XsvZQDC7gg7NVatm7Ikox7HzaG90BQT8Adiy3Djgg.ObjayP-BHx1u1db-c-9RQRPPeRa-PPnn-U7p-X-29X4g.PNG.depeix/%EC%BA%A1%EC%B2%9813.PNG?type=w773)<br></br>
MD5 hash를 조회해본 결과 admin 계정의 비밀번호가 password 인 것을 볼 수 있다.<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfNTAg/MDAxNTk4NTgzOTMyMzc4.0mZHSVCkZRflTJVONgJdziGt2kv-NjuG9Ob95JVsmVsg.EjF9mIfUbHw4WYe5xzJYgGfxVOvsjucxnNVit8OF3-Yg.PNG.depeix/%EC%BA%A1%EC%B2%9814.PNG?type=w773)<br></br>
<br></br><br></br>

# Medium 레벨<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMjgz/MDAxNTk4NTgzOTM1MzEz.WjbAPTrtfvFWcnrGdyjSd5IvK-g1NZdd7OtVrUl-8YYg.yOTmGhEPKrSjd2upFg3N7QfrPUIlAgJHoQumTVqu7ygg.PNG.depeix/%EC%BA%A1%EC%B2%9815.PNG?type=w773)<br></br>
Medium 레벨의 경우 Low 레벨과 달리 User ID를 선택할 때, 사용자가 입력하는 폼이 없고 드롭다운 메뉴 형태로 되어 있다.<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfODcg/MDAxNTk4NTgzOTQxNjQw.LxNRhM1gmmWDhcwf2ml5O1L4Rseb_XXSssQ_D0Yq6ekg.kLpEhfkfVNohpM-gWQOkGYaLTRXJmx4TCLA4Cbwa0GAg.PNG.depeix/%EC%BA%A1%EC%B2%9816.PNG?type=w773)<br></br>
BurpSuite로 패킷 캡쳐후 id 파라미터에 싱글 쿼테이션(‘)을 추가한 뒤 Forward 버튼을 클릭한다.<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfNzgg/MDAxNTk4NTgzOTQ2MjI0.NUbuoH32Xz85rSaOhJ7yrHZ9xHwHHaXk0vRyh5JOK1Yg.1295L80NxnNfEvLF-AZkAx-rVp64G5mf3jfFtDpldsIg.PNG.depeix/%EC%BA%A1%EC%B2%9817.PNG?type=w773)<br></br>
Low 레벨과 유사한 오류를 확인할 수 있다.<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfOSAg/MDAxNTk4NTgzOTUxODI3.lp1k1cq5nz7SO-abNnbWZvEodHfKVAXaELcs3cOlfcAg.GOLVklmivvBh9UT7VFbyLLPzH7wPuGT6_6UWpCNrXzog.PNG.depeix/%EC%BA%A1%EC%B2%9818.PNG?type=w773)<br></br>
id 파라미터가 무조건 참이 되도록 ‘or 1=1’을 입력한 후 Forward 버튼을 클릭해 보자.<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfNTQg/MDAxNTk4NTgzOTU0NTM2.6EyqMVWj2WnuoXq7z8FltWHnlEZWpJXs7Tvjrg_mB9og.kietS35hIS9ZRPpAl0e-ytoc4Ll6AFTl-VEBsc0LKCkg.PNG.depeix/%EC%BA%A1%EC%B2%9819.PNG?type=w773)<br></br>
SQL Injection 공격이 성공한 것을 확인할 수 있다.
<br></br><br></br>
# High 레벨<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMTAx/MDAxNTk4NTgzOTU3MDY3.3wXkQvVBIz7EoVp3REJdwTAotkQ0QUykgp-IcCyj3Iwg.VdBGhB1Kt--RIZmI87k1Z0zoU15LN8G8wohGe_OL9_8g.PNG.depeix/%EC%BA%A1%EC%B2%9820.PNG?type=w773)<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMjc1/MDAxNTk4NTgzOTYwMjA5.wphiu4hiOzCbtS820Me58IYgcOEf0R4l0Zo69uNCtvkg.9x8pEYJi0p-H2xP6TDSO40y3VE8IcOmVuCrb-Ei2xrQg.PNG.depeix/%EC%BA%A1%EC%B2%9821.PNG?type=w773)<br></br>
High 레벨에서는 입력 폼 자체가 존재하지 않으며 “here to change your ID.”를 클릭시 별도의 페이지가 열리는 구조로 구성되어 있다.<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfOTUg/MDAxNTk4NTgzOTYzNzUz.VmYqJRJa47LfnpH06FsWy7Rc_c0-kNxiD3ujPiI3pz8g.0Ne_qCyF0piCrr7zceOs44GIgLEgEOKPqI6yDccUhmcg.PNG.depeix/%EC%BA%A1%EC%B2%9822.PNG?type=w773)<br></br>
Submit을 누룰시 원래의 페이지에서 결과가 출력된다.<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMTM2/MDAxNTk4NTgzOTY2OTU2.Miy7BIp1w6qypfkcabYbif5XXpbA5Fb2P9oebfi_iD0g.YlMHb1Q0fd9-jpWMar9AIxczsRnigxXBkTwIIst_eakg.PNG.depeix/%EC%BA%A1%EC%B2%9823.PNG?type=w773)<br></br>
입력값으로 싱글 쿼테이션(‘)을 넣으면 단순 오류 페이지만 발생하는 것을 볼 수 있다.<br></br>
하지만 이것만으로는 SQL Injection 취약점이 존재하는지 판단할 수 없다. or를 이용해서 참으로 만들어보자.<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMjk4/MDAxNTk4NTgzOTY5Nzk2.BYzgXxuMFfo7dIwylEvq7vnVwne2i8K1YPfc3Y6GYYUg.IJ5WMbBX_luCGTXGkvlULWbk73X6u7CLGmdAGwUms-4g.PNG.depeix/%EC%BA%A1%EC%B2%9824.PNG?type=w773)<br></br>
Low 레벨과 다르게 결과가 1개 밖에 나오지 않는다. 그렇다면 쿼리문 뒷부분에 추가 쿼리를 실행하지 못하게 LIMIT 구문이 있을 것이라는 추측을 해볼 수 있다.
LIMIT 구문을 우회하기 위해 입력 값 뒤에 #을 추가하여 실행하면 LIMIT가 주석 처리되어 SQL Injection 공격이 성공한 것을 확인할 수 있다.<br></br>
![](https://postfiles.pstatic.net/MjAyMDA4MjhfMjEw/MDAxNTk4NTgzOTcyODQ4.rBgFOcyQ5RC-1XV-yfTbCQ3--lw2QinOOrwnVr86AIQg.GlRsT5BW1lgM0bi2OqSwRqiH0EGYw4aQPp3lmwbQviUg.PNG.depeix/%EC%BA%A1%EC%B2%9825.PNG?type=w773)<br></br>
LIMIT 문을 우회한 경우 medium, Low 레벨에서의 공격에 썻던 구문이 다 통하는 것을 볼수 있다.
