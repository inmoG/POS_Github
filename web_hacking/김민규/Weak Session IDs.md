# Weak Session IDs
</br></br></br>


# 개념

웹 애플리케이션 구현에 있어서 서비스에 접근하는 `사용자의 인증 값`이나 `세션, 쿠키 생성/관리` 구현에서 발생하는 취약점을 공격하는 기법이다. 이러한 취약점을 이용하여 비인가자가 로그인 없이 서비스 페이지에 접근하거나 관리자 페이지까지 접근할 수 있다.</br>
또한, 다른 사용자의 인증 값을 가로채서 다른 사용자인 것처럼 가장할 수 있다.
</br>

- ### 세션
  - 클라이언트와 웹 서버 간 일정 시간동안 논리적 연결 방법을 의미하며, `사용자 연결 정보`는 웹 서버 상에 저장하고, `세션 ID`는 쿠키로 저장한다. </br></br>
    - ### 세션 ID
      - 웹 서버가 `다수의 웹 페이지 요청자를 구별하기 위해` 각 사용자의 세션에 대해서 부여하는 `임의의 긴 문자열 ID 값`이다.</br> 클라이언트는 해당 웹 페이지에 접속할 때마다 웹 브라우저에 저장된 세션 ID 쿠키 값을 웹 서버에 전송하여 </br> 웹 서버가 자신을 구분할 수 있게 한다.</br></br>
    - ### 세션 동작원리
      - 1. 클라이언트(웹 브라우저)에서 페이지 요청
      - 2. 웹 서버에서는 `HTTP Request` 정보 내 `세션 ID`를 확인
      - 3. `세션 ID가 없을 경우` 세션 ID 값을 생성 후 클라이언트에 HTTP Response로 전송
      - 4. 클라이언트는 세션 ID를 쿠키에 저장
      - 5. 클라이언트가 `HTTP Request 내 세션 ID를 포함`하여 전송 
      - 6. 웹 서버는 세션 ID를 기반으로 `이전 상태 정보를 확인`

- ### 쿠키
  - 웹 서버에서 생성하여 웹 브라우저에게 보내어 저장했다가 `서버의 부가적인 요청`이 있을 때 다시 서버로 보내주는 문자열 정보를 의미한다. </br></br>
    - ### 쿠키의 5가지 구성요소
      - NAME = VALUE
      - expires = DATE
      - path = PATH
      - domain = DOMAIN_NAME</br></br>
      - 이름(NAME)과 값(VELUE)의 쌍을 제외한 다른 구성요소는 모두 `쿠키의 유효 여부를 판단`하는 데 사용된다. </br>`각 구성요소에 입력된 값과 모두 일치하는 서버만이 그 쿠키를 참조`할 수 있다.</br></br>
    - ### 쿠키 동작원리
      - 1. 클라이언트(웹 브라우저)에서 페이지 요청
      - 2. 웹 서버에서 응답할 때 `요청된 페이지에 대해 HTTP 헤더에 쿠키를 포함`
      - 3. 응답된 쿠키정보를 `클라이언트 측에서 저장 및 관리`
      - 4. 클라이언트에서 재요청 시 `HTTP Request 정보 내에 쿠키를 함께 전송`
      - 5. 웹 서버는 쿠키 정보를 읽어들인 후 `이전 상태 정보를 확인`
        </br></br>
- ### 세션과 쿠키의 비교
    |구분|세션|쿠키|
    |:-:|:--:|:--:|
    |저장위치|서버|클라이언트|
    |저장형식|객체 형|텍스트 형식|
    |자원사용|서버 리소스 사용|클라이언트 리소스 사용|
    |용량제한|서버 설정에 따라 다름|한 도메인당 20개 총 300개 저장|
    |용도|서버 이용 시 사용자 정보 유지|사이트 재방문 시 사용자 정보 기억|
    | |
</br></br></br></br>



# 공격
</br>

dvwa 내에서 Weak Session IDs 공격 실습은 사이트의 정보를 빼내오는 것이 아니라 `HTTP Request` 내용 중 쿠키에 포함된 `세션 값의 패턴`을 알아내는 것이다. </br>
세션의 패턴을 파악하면 세션 값 조작을 통한 로그인 우회와 권한 상승 등의 공격에 사용할 수 있다.</br>
물론, 세션 값의 패턴 외에도 다른 정보가 필요하지만 dvwa 실습에서는 세션 값의 패턴만 파악해보도록 하자.
</br></br></br>


# Low 레벨

![](https://images.velog.io/images/kmk9502/post/655dc09b-ab3c-4ecf-9b42-8afc258d8f8c/Weak%20Session%20IDs%20%ED%8E%98%EC%9D%B4%EC%A7%80.png)

패킷 캡처 도구인 BurpSuite를 실행하고 화면에 보이는 Generate 버튼을 클릭하여 요청 값을 확인해보자.

그 전에 먼저 Low 레벨에서의 소스코드를 분석하여 세션에 어떤 값이 들어갈지 살펴보자.

![](https://images.velog.io/images/kmk9502/post/799708ee-f922-44ec-9321-5399738c9ae8/%EC%86%8C%EC%8A%A4%20%EC%BD%94%EB%93%9C.png)

소스코드를 보면 처음 세션 값이 존재하지 않을 때 세션 값을 0으로 할당하고, 그 다음 요청부터 1씩 증가시키는 것을 알 수 있다. </br>
즉, 버튼을 클릭할 때마다 1씩 세션 값을 증가시키는 간단한 패턴이다.

![첫 번째 요청 값](https://images.velog.io/images/kmk9502/post/5eca2ba3-cd81-43f6-8d8c-442bb0865360/%EC%84%B8%EC%85%98%20ID%20%EA%B0%92.png)

첫 번째 HTTP Request

![두 번째 요청 값](https://images.velog.io/images/kmk9502/post/76bf39de-dcdb-4885-9be9-a92b7ba52e1a/%EC%9A%94%EC%B2%AD%EC%9D%84%20%EB%B3%B4%EB%82%BC%20%EB%95%8C%EB%A7%88%EB%8B%A4%20%EC%84%B8%EC%85%98%20%EA%B0%92%201%20%EC%A6%9D%EA%B0%80.png)

두 번째 HTTP Request

실제 요청 값에서 소스코드에서 보았던 요청 시 세션 값 1이 증가하는 패턴을 확인할 수 있다. 
</br></br></br>

# Medium 레벨

Low 레벨과 마찬가지로 BurpSuite를 활용해 요청 패킷을 캡처해보자.

![](https://images.velog.io/images/kmk9502/post/4a6f3cfa-b53b-44dd-985b-5a3e0f11fb68/%EC%84%B8%EC%85%98%20%EA%B0%92%EC%9D%98%20%EB%B3%80%ED%99%94.png)

쿠키에 있는 세션 값에 불규칙해 보이는 값이 존재한다는 것을 확인할 수 있다. 

세션 값의 정체가 무엇인지 소스 코드를 분석하여 알아보자.

![](https://images.velog.io/images/kmk9502/post/15a3ad89-f546-490e-9561-75e427e4c858/%EC%84%B8%EC%85%98%20%EA%B0%92%EC%9D%98%20%EC%A0%95%EC%B2%B4.png)

세션 값은 소스 코드 상에 존재하는 `time()` 함수가 생성하는 것을 확인할 수 있다. </br>
time() 함수는 현재의 유닉스 타임스탬프 값을 반환해주는 함수로써 1970년 1월 1일 0시 0분 0초로부터 현재까지 </br>
지나온 `초`를 계산하여 정수 형태로 반환하는 기능을 한다.</br>

세션 값인 유닉스 타임스탬프 값을 변환해 주는 웹 사이트를 활용하여 세션 값을 변환해보자.

![](https://images.velog.io/images/kmk9502/post/5f8c3c54-070e-47f1-b326-f7567a0ceca9/%ED%83%80%EC%9E%84%20%EC%8A%A4%ED%83%AC%ED%94%84%20%EB%B3%80%ED%99%98.png)

변환한 결과, 세션 값은 2020년 8월 26일 수요일 오전 5시 52분 32초임을 알 수 있다.
</br></br></br>


# High 레벨

이전 레벨과 동일하게 Generate 버튼을 누를 때 BurpSuite로 패킷 캡처를 한다. 

그러나 이번에는 세션 값에 이전 Medium 레벨에서 받았던 세션 값이 표시된다. </br>

![](https://images.velog.io/images/kmk9502/post/a0e559fc-620f-4974-8b6e-1bd62c377db4/%EC%9A%94%EC%B2%AD%20%EA%B0%92%20%EB%AC%B8%EC%A0%9C%20%EB%B0%9C%EC%83%9D.png)

이는 클라이언트 측에서 기존에 가지고 있던 Medium 레벨의 쿠키 값을 그대로 High 레벨에서 사용하여 서버 측에 전송하고 이를 High 레벨에서의 php를 통해 해석하기 때문에 보안 레벨은 high로 인식되지만, 세션 값은 Medium 레벨과 같다. 

따라서 Request가 아닌 `Response 패킷`을 확인하도록 하자. 

![](https://images.velog.io/images/kmk9502/post/271b9699-991c-47ff-8659-23a5c01c6cdd/%EC%9D%91%EB%8B%B5%20%EA%B0%92%EC%97%90%EC%84%9C%20%EC%84%B8%EC%85%98%20%ED%99%95%EC%9D%B8.png)

응답 패킷을 보니 숫자와 영문자가 섞인 긴 문자열이 존재하는 것을 확인할 수 있다. </br>

소스코드를 분석하여 해당 문자열의 정체를 알아내보자.

![](https://images.velog.io/images/kmk9502/post/e5af09c1-cc34-4db1-9466-1ff93a385822/%EC%86%8C%EC%8A%A4%20%EC%BD%94%EB%93%9C.png)

빨간 색 원을 보면 High 레벨에서는 Low 레벨과 같이 1씩 세션 값을 증가시키지만, </br>
증가시킨 세션 값을 `md5`로 암호화하여 전송하는 것을 확인할 수 있다.

md5를 복호화하는 웹 사이트로 해당 세션 값을 복호화해보자.

![](https://images.velog.io/images/kmk9502/post/31925612-0d59-4037-bff3-80fdc26dd65b/%EC%84%B8%EC%85%98%EA%B0%92%20md5%20%EB%B3%B5%ED%98%B8%ED%99%94.png)

복호화 결과, md5로 암호화된 값은 17임을 알 수 있었다. 

추가로 두 번째 요청의 세션 값을 복호화하면 17에 1을 더해 18이 되는지 확인해보자.

![](https://images.velog.io/images/kmk9502/post/3b84d05f-e0a6-412a-8071-62755d29b0f1/2%EB%B2%88%EC%A7%B8%20%EC%84%B8%EC%85%98%20%EA%B0%92%20%ED%99%95%EC%9D%B8.png)

![](https://images.velog.io/images/kmk9502/post/f5d897ff-76bf-4149-859b-aa1c30ad2000/%EB%91%90%20%EB%B2%88%EC%A7%B8%20%EC%84%B8%EC%85%98%20%EA%B0%92%20md5%20%EB%B3%B5%ED%98%B8%ED%99%94%20%ED%99%95%EC%9D%B8.png)

결과를 보니 역시 소스코드의 내용대로 세션 값이 1 증가했고, md5로 암호화된 것을 확인할 수 있었다.