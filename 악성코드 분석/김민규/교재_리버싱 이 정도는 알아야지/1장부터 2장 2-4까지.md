# 1장 리버싱 시작하기

- ## 리버싱 기초 개념 집고 넘어가기
|용어|정의
|:--:|:--|
|운영체제|시스템 하드웨어를 관리할 뿐 아니라 응용 소프트웨어를 실행하기 위하여 </br>하드웨어 추상화 플랫폼과 공통 시스템 서비스를 제공하는 시스템 소프트웨어|
|파일 시스템|컴퓨터에서 파일이나 자료를 쉽게 발견 및 접근할 수 있도록 보관 또는 조직하는 </br>체제를 가리키는 것</br>Ex> FAT, NTFS 등|
|메인 메모리|메인 메모리는 RAM이라는 저장 장치로 구성되어 있다. 컴파일이 완료된 프로그램 </br>코드가 올라가서 실행되는 영역|
|실행 파일|단순히 데이터만 담고 있는 파일과 달리 코드화된 명령에 따라 지시된</br> 작업을 수행하도록 하는 컴퓨터 파일. 즉, 실행되는 파일|
|프로세스|컴퓨터 분야에서 프로세스는 '실행 중인 프로그램'이라는 뜻. </br>즉, 디스크에서 메모리로 올라가 실행되고 있는 프로그램|
||

- ## PE 파일 구조
  - ### 정의
    - Windows OS에서 실행되는 파일은 컴파일 과정에서 MS에서 정한 규칙에 맞게 데이터가 채워지고 </br>그 결과, 파일이 정상적으로 실행 가능하게 된다. </br>즉, 윈도우 OS에서 실행 가능한 파일 구조가 PE 파일 구조이다.
  - ### PE File Section
    - PE Header : 파일을 실행시키기 위해 필요한 정보가 기록되어 있는 영역
    - .text Section : 파일이 동작하는 데 필요한 코드가 기록되어 있는 영역
    - .data Section : 코드가 실행될 때 필요한 부가적인 정보가 기록되어 있는 영역
    - Ex> printf("Hellow world!") 함수에서 printf()는 .text 영역에 기록되고, Hellow world!는 .data 영역에 기록
- ## 무작정 분석해보기_사전 탐색
  - ### 분석 자료
    - Sample 01.exe
   
 ![](https://images.velog.io/images/kmk9502/post/d7a9f241-b6db-408c-b803-e1c544e65815/Sample01.exe%20%EC%8B%A4%ED%96%89.png)

- ### 실행 결과
  - Beep sound와 Message box가 출력되었다. 

- ## 무작정 분석해보기_본격 분석

  ![](https://images.velog.io/images/kmk9502/post/807f0bc8-79aa-47f2-a48f-c12ad2d4403e/Sample01%EC%9D%98%20Main%20%ED%95%A8%EC%88%98%20%EC%98%81%EC%97%AD.png)
   
- ### Main() 찾기
  - main() 함수는 00401000 주소에 위치하고 있다. 
- ### 호출 함수 찾기
  - Beep 음을 출력하는 Beep() 함수와 메시지 박스를 출력하는 MessageBoxA()가 존재한다.
- ### 함수의 인자 값
  - Beep() : </br>파일 실행 후 Beep 음을 출력하는 시간까지의 간격을 제어하는Duration(), </br>그리고 Beep 음의 주파수를 설정하는 Frequency()에 대한 인자값을 받는다.
  - MessageBoxA() : </br>메시지 박스의 스타일을 설정하는 Style() </br>메시지 박스의 제목을 설정하는 Title() </br>메시지 박스가 출력할 내용을 입력 받는 Text() </br>메시지 상자의 소유자 창을 설정할 수 있는 hOwner()

</br>

  ![](https://images.velog.io/images/kmk9502/post/1cf191a8-c316-492b-aaec-6836dbdf1641/%EB%A9%94%EC%8B%9C%EC%A7%80%20%EB%B0%95%EC%8A%A4%20%EC%B6%9C%EB%A0%A5%20%EB%AC%B8%EC%9E%90%EC%97%B4.png) 

  - ### data Section
    - MessageBoxA() 함수에 전달되는 문자열 인자 값이 저장된 공간
    - 문자열이 아스키 코드 값 형태로 변환되어 저장됨

  ![](https://images.velog.io/images/kmk9502/post/e19f4426-8fd6-4fb6-b99c-3d5530a408b2/DLL%20%EB%B3%B5%EC%82%AC%EB%B3%B8.png)

  - ### Win32 API 함수가 호출하는 DLL들
    - 붉은 줄 아래에 존재하는 KERNELBA, USP10, GDI32, USER32 등의 파일을 DLL 파일이라고 한다.
  - ### DLL?
    - 동적 링크 라이브러리의 약자이며, 쉽게 표현하면 exe 파일에서 사용하는 API 함수의 심부름꾼이다.
    - 실행 중 API 함수를 호출하면 `API 함수는 자신의 기능을 구현하기 위해` 특정 DLL 파일에게 자신의 정보를 </br>전달한다. 그렇게 전달 받은 정보는 다시 다른 DLL을 거치고 거쳐 최종적으로 `커널`에 전달되며 API 함수의</br>`기능이 실제로 구현된다.`
    - API 함수를 호출할 땐, 호출 시 필요한 `인자 정보`가 있고, 이 정보들을 `명확히 dll에게 전달해야 정확한 행위가 일어난다.`

  - ### API?
    - 운영체제가 기본 제공하는 `특정 기능을 수행하는 함수`이다.
    - 특정 기능을 구현할 때마다 일일이 코드를 작성하는 수고로움을 덜기 위해 개발되었다.
    - 각 운영체제는 서로 다른 API 및 DLL을 사용한다. 
    - https://github.com/inmoG/POS_Github/blob/master/%EC%95%85%EC%84%B1%EC%BD%94%EB%93%9C%20%EB%B6%84%EC%84%9D/%EA%B9%80%EB%AF%BC%EA%B7%9C/%EA%B5%AC%EC%A1%B0%EC%A0%81%20%EC%A0%91%EA%B7%BC%EB%B0%A9%EB%B2%95_%ED%8C%8C%EC%9D%BC%20%EB%B6%84%EC%84%9D.md 참고


  ![](https://images.velog.io/images/kmk9502/post/c53e1a05-4950-4462-9356-555c5b54da65/USER32.dll%EC%9D%98%20MessageBoxA%20%EA%B8%B0%EB%8A%A5%20%EC%88%98%ED%96%89.png)

  - ### 실제 API 함수의 DLL 호출
    - User32.dll이라는 심부름꾼에게 메시지 박스를 띄워 달라는 요청

</br></br>

  ![](https://images.velog.io/images/kmk9502/post/19ae5c65-d6f3-47e0-a027-bacd95b83e04/%EB%A9%94%EC%8B%9C%EC%A7%80%20%EB%B0%95%EC%8A%A4%20%EC%8B%A4%ED%96%89.png)

  - ### MessageBoxA() 실행

</br></br></br></br>

# 2장 Windows 리버싱 기초

- ## PE File Format 이해
  - ### 정의
    - **PE File**은 Microsoft에서 정의한 `실행파일 형식`이다. 그렇기 때문에 Windows OS에서 동작하는 프로그램은 </br>모두 **PE File Format**을 취하고 있다. 
  - ### 종류
    - exe, sys, dll 등의 실행 가능한 파일
  - ### PE File 생성
    - PE File은 프로그래머가 작성한 값이 아니다. 윈도우 운영체제가 코드를 컴파일하는 단계에서 파일의 형식을 </br>자동으로 PE File Format으로 작성하는 것이다.  </br>즉, 운영체제가 자신이 사용하는 실행파일 형식으로 코드를 컴파일 한다. </br>윈도우 OS : PE File Format </br>리눅스/유닉스 기반 OS : ELF File Format
- ## PE Header
  - ### 구성
    - PE Header는 **DOS Header**, **DOS Stub**, **NT Header**, **Section Header**로 나뉘어져 있다.  </br>다음 사진은 PE Header의 개략적인 구조이다.

    ![](https://images.velog.io/images/kmk9502/post/448d24e6-63bb-4ef3-a09f-ebfb1d20f350/PE%20Header%20%EA%B5%AC%EC%A1%B0.png) 

  - ### 의미
    - 각 항목의 의미와 역할은 다음과 같다. PE 파일 실행과 관련된 중요 정보들은 대부분 **NT Header**에 기록되어 있다.
     
    |Header Name|설명|
    |:---------:|:---|
    |DOS Header| DOS Header는 DOS와 호환성을 위해서 만들었다. 파일의 처음에 위치하고, 0x40 크기를 가진다.</br>DOS란 MS-DOS를 뜻하며 Microsoft가 1981년 최초로 대중화한 운영체제이다.|
    |DOS Stub|해당 파일이 MS-DOS에서 실행될 경우 화면에 출력될 메시지와 코드가 기록되어 있다. </br>DOS Stub은 옵션이기 때문에 **파일 실행에 영향이 없다.** 크기가 일정하지 않고 **없어도 되는 영역이다.**|
    |NT Header|파일 실행에 필요한 전반적인 정보를 담고 있다. 0xF8 크기를 가진다.|
    |Section Header|각 섹션의 속성 정보를 담고 있다.|
    ||

    </br>

    - PE Header의 구체적인 정보는 아래와 같다.

      ![](https://images.velog.io/images/kmk9502/post/66e4593b-79e2-49e7-ba13-291672686cdd/PE%20Header%20%EA%B5%AC%EC%B2%B4%EC%A0%81%20%EA%B5%AC%EC%A1%B0.png)

      - ### (1) DOS Header
        - **DOS Signature**
            - **실행 파일이라는 표식**이다. 크기는 2byte이고 "MZ(0x5A4D)" 값을 가진다.
        - **NT Header Offset**
            - **NT 헤더의 시작 지점**에 대한 정보를 담고 있다.
      - ### (2) NT Header
        - **Signature**
          - **올바른 PE 파일인지 확인**하는 용도로 사용된다. 크기는 4byte이고 "0x50450000" 값을 가진다.
        - **FILE HEADER**
          - **파일의 Physical(물리적) 정보**를 담고 있는 구조체이다.
        - **OPTIONAL HEADER**
          - **파일의 Logical(논리적) 정보**를 담고 있는 구조체이다.

          </br></br>
          
        - **<FILE HEADER 구조체**와 **OPTIONAL HEADER 구조체>**
        - **<FILE HEADER 구조체>**
          - Machine
            - 파일이 실행될 CPU 타입 정보를 담고 있다.
              - 0x014C -> intel 386
              - 0x0200 -> intel 64
          - Number of Sections
            - 파일의 섹션 개수 정보를 담고 있다.
          - Size of Optional Header
            - Optional Header 크기 값을 가지고 있다. 일반적으로 oxE0 값을 가진다.
          - **Characteristics**
            - 파일의 속성 정보를 가지고 있다. **이 값으로 exe와 dll의 구분이 가능하다.**  
              - 0x0002 -> 실행 가능한 파일
              - 0x0100 -> 32bit 실행 파일
              - 0x2000 -> DLL 파일
        - **<OPTIONAL HEADER 구조체>**
          - Magic
            - Magic은 Optional Header가 IMAGE_OPTIONAL_HEADER32 구조체인 경우 0x010B, </br>IMAGE_OPTIONAL_HEADER64 구조체인 경우 0x020B 값을 가진다.
          - **Address of EntryPoint**
            - 파일의 코드 시작 지점에 대한 RVA 값을 가지고 있다. 즉, 메모리 상에서 파일 내의 코드 시작 주소를 가리킨다.
          - **Image Base**
            - 파일 데이터가 메모리에 올라갈 때, 기준이 되는 주소 값을 가지고 있다. 즉, 메모리 상에서 파일 데이터가 위치한 메모리 주소를 가리킨다. 기본적으로 exe는 0x00400000, DLL은 0x10000000 값을 가지고 있다.
          - Section Alignment / File Alignment
            - PE 파일의 Body 부분은 섹션으로 나누어져 있다. 파일 상태에서 섹션의 최소 단위를 나타내는 것이 File Alignment이고 메모리에서 섹션의 최소 단위를 나타내는 것이 SectionAlignment이다. 하나의 파일에서 두 값은 같을 수 있고 다를 수도 있다. </br>파일 / 메모리의 섹션 크기는 반드시 FileAlignment / SectionAlignment의 배수가 되어야 한다.(두 값은 최소 단위이기 때문에)
              - 파일 상태?
                - 메모리에 올라오기 전의 상태. 즉, 실행 전 상태로, 디스크에 있을 때의 상태이다.
          - **Size of image**
            - 메모리에 올라간 파일 데이터의 크기 값을 나타낸다.
          - Size of Headers
            - DOS Header, NT Header, Section Header를 합친 총 크기 값을 나타낸다.
          - Number of Data Directories
            - Data Directory의 개수를 나타낸다.
          - **Data Directories**
            - Data Directories는 Number of Data Directories 필드의 개수만큼 활성화된다. 일반적으로 0x10개의 정보가 기록되어 있지만 필수는 아니다. </br>초보자는 아래 사진에서 EXPORT Table과 IMPORT Table의 RVA, SIZE 값이 Data Directories에 기록되어 있다는 것만 기억해도 된다.

            ![](https://images.velog.io/images/kmk9502/post/2076512f-6249-4249-a06d-00face0e711e/Number%20of%20Data%20Directories.png)

      - ### (3) Section Header
        - VirtualSize
          - 메모리에서 섹션이 차지하는 크기이다.
        - **RVA(VirtualAddress)**
          - 메모리에서 섹션의 시작 주소이다.
        - SizeOfRawData
          - 파일에서 섹션이 차지하는 크기이다.
        - **PointertoRawData**
          - 파일에서 섹션의 시작 주소이다.
        - Characteristics 
          - 섹션의 속성 정보를 담고 있다.

        </br></br>

      - ### 위에서 언급된 '메모리'의 진실
        - 위 글에서 반복적으로 언급된 '메모리'는 사실 실제 하드웨어 메모리에 올라가기 전에 거쳐야 하는 **가상 메모리**를 의미한다. </br>https://github.com/inmoG/POS_Github/blob/master/Reverse%20Engineering/%EA%B9%80%EB%AF%BC%EA%B7%9C/%EB%A6%AC%EB%B2%84%EC%8B%B1%20%EC%B4%88%EA%B8%89_%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%20%EC%9D%B4%ED%95%B4/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B5%AC%EC%84%B1_CPU%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EB%B0%8F%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%20%EB%8F%99%EC%9E%91%20%EC%9B%90%EB%A6%AC.md 참고

      - ### RVA와 RAW, 그리고 RVA to RAW 계산법
        - **RVA(VirtualAddress)**
          - 간단히 말해서 **가상 메모리 상의 주소**이다. 아래 사진처럼 `섹션 헤더에 존재하는 RVA`는 일반 메모리 주소와 약간 다른 의미를 지닌다. 바로 `메모리 상에서 해당 섹션의 시작 주소이다.`
          - 메모리 상에서 섹션의 시작 주소를 나타내는 RVA 값은 `VirtualAddress`로 표현할 수 있다.

            ![](https://images.velog.io/images/kmk9502/post/2fa02a48-f0bc-4d1a-b35e-824cb2bc28f1/Section%20Header%EC%9D%98%20RVA.png) 

        - **RAW**
          - **파일 상태에서의 주소**이다. 그러나 메모리 상에 올라온 PE File에서는 RAW 값을 찾을 수 없다. 
          - RAW 값은 RVA to RAW 게산을 사용해 쉽게 구할 수 있다.
         - **RVA to RAW 계산**
          - PE 파일이 메모리에 로딩되었을 때 각 섹션에서 메모리의 주소(RVA)와 파일 offset(파일 상태의 주소)을 매핑하는 방법
          - 과정
            - 1. RVA가 속한 섹션을 찾는다.
            - 2. 간단한 비례식을 통해 파일 offset(RAW)를 계산
          - 계산
            - RAW - PointerToRawData = RVA - VirtualAddress 
            - 즉, RAW에서 파일 상태의 섹션의 시작 주소를 뺀 값은 RVA(메모리 주소)에서 RVA가 속한 섹션의 시작 주소를 뺀 값과 같다. 이 비례식을 근거로 다음의 공식을 세울 수 있다.
            - **RAW = RVA - VirtualAddress + PointerToRawData**

            </br></br>

      - ### (4) IAT(Import Address Table)와 EAT(Export Address Table)
        - **IAT**
          - DLL이 제공하는 함수들 중에서 실제로 사용하는 것들에 대한 정보를 기술해놓은 테이블
          - PE Loader가 exe 파일을 컴파일 할 때 필요한 함수 호출 주소 정보를 획득해서 IAT에 기록한다.
          - exe파일은 동작 과정에서 필요할 때마다 **IAT를 참고**해서 **함수를 호출**한다.
          - **exe 뿐만 아니라 dll도 IAT를 가진다.** 아래 사진은 kernel32.dll이 사용하는 dll들이다.

          ![](https://images.velog.io/images/kmk9502/post/89317b94-1b9c-487e-be19-07eacadf6ca2/kernel32.dll%EC%9D%B4%20%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%20dll%EB%93%A4.png) 

            </br></br>

        - **실제 Beep() API 함수 호출 주소 획득 과정**


          - **IMPORT Directory Table**
            - IMPORT Directory Table에는 PE 파일에 필요한 **DLL 수만큼** IMAGE_IMPORT_DESCRIPTOR 구조체가 생성되며 배열로 존재한다.
            - DLL과 DLL이 제공하는 함수들 중에 사용하는 것들에 대한 **정보의 위치를 기록해놓은 저장소**라고 보면 된다.
            - 아래 사진에서 네 번째 멤버 값인 Name RVA는 DLL 이름 문자열이 기록되어 있는 위치 정보이다. 해당 주소에서 DLL 이름을 확인하고 메모리에 로드한다.
            - 아래 사진에서 붉은 색 원은 해당 exe 파일이 사용하는 DLL이며, 각 DLL의 영역이 구분되어 있는 것을 볼 수 있다.

            ![](https://images.velog.io/images/kmk9502/post/dad3e40e-9dbd-4483-aaa8-02f4042e0613/Import%20Directory%20Table%20%EC%A0%95%EB%B3%B4.png) 

             </br></br>

           - **IMPORT Name Table**
             - 위 사진에서 첫 번째 멤버 값인 Import Name Table RVA는 **DLL이 제공하는 함수들의 이름 정보만을** 담고 있는 Table 주소이다. 
               - **Kernel32.dll** 
                 - 메모리 관리, 입출력 명령, 프로세스와 스레드 생성, 그리고 동기화 함수들 같은 대부분의 API 함수들을 **응용 프로그램에 내보낸다.** </br>즉, 위와 같이 열거된 수많은 기능들을 **API 함수 형태로 응용 프로그램에 제공한다.**
                 - 응용 프로그램이 kernel32.dll이 제공한 API 함수를 사용하면 API 함수는 kernel32.dll에게 기능 구현에 대한 정보를 제공하고 dll은 커널에 기능 구현을 요청한다.
                 - https://github.com/inmoG/POS_Github/blob/master/%EC%95%85%EC%84%B1%EC%BD%94%EB%93%9C%20%EB%B6%84%EC%84%9D/%EA%B9%80%EB%AF%BC%EA%B7%9C/%EA%B5%AC%EC%A1%B0%EC%A0%81%20%EC%A0%91%EA%B7%BC%EB%B0%A9%EB%B2%95_%ED%8C%8C%EC%9D%BC%20%EB%B6%84%EC%84%9D.md 참고
                 - 아래 사진은 IMPORT Name Table의 모습이다. kernel32.dll과 user32.dll이 제공하는 함수들의 이름 정보를 볼 수 있다.
                 - OllyDbg에서 아래 사진의 Data 항목에 있는 주소로 가면 해당 함수의 이름이 기록되어 있는 것을 볼 수 있다.

              ![](https://images.velog.io/images/kmk9502/post/07986715-a079-485e-9e4a-377354f23d3f/INT%20%EC%A0%95%EB%B3%B4.png) 

              </br></br>

            - **EAT**
              - EAT는 Export Address Table의 약자로, **DLL이 제공하는 함수들의 주소 정보**를 담고 있는 Table이다.
              - 위의 IMPORT Name Table에서 사용할 함수 이름을 선택한 후 해당 함수를 제공하는 DLL의 EAT로 </br>접근하여 **선택한 함수의 실제 호출 주소 정보를 얻는다.** </br>그리고 그 정보를 IMPORT Address Table. 즉, IAT에 기록한다.
            - **순서 요약**
              - kernel32.dll이 제공하는 함수를 사용한다는 가정 하에 진행</br></br>
              - 1. IMPORT Name Table 중 사용할 함수들을 선택
              - 2. Export Address Table에서 사용할 함수들의 주소 정보 획득
              - 3. Import Address Table의 kernel32.dll 영역에 실제 사용할 함수 주소 등록
              - 아래 사진은 IAT에 등록된 함수 주소 목록이다. INT와 비교했을 때 함수 값에 차이가 없는 것을</br> 확인할 수 있다. 이를 통해 INT의 모든 함수가 IAT에 등록되었다는 것을 알 수 있다.

            ![](https://images.velog.io/images/kmk9502/post/fb318a4b-0b73-4863-af65-2d5972b082ba/IAT%20%EC%A0%95%EB%B3%B4.png) 

            </br></br>

- ## OllyDbg 화면 구성
 
  ![](https://images.velog.io/images/kmk9502/post/900da557-b6c3-4fec-aa7e-54d0aaefd6f2/OllyDbg%20%EA%B5%AC%EC%84%B1.png) 

  - ### (1) Disassemble 영역
    - 메모리에 올라간 PE 데이터 중에서 **.text** 섹션에 기록되어 있는 기계어 코드를 보여준다.
    - OllyDbg는 기계어를 보기 쉽게 어셈블리어로 번역해서 (1) 영역에 띄워주고 어셈블리 코드를 실행 또는 중지할 수 있는 환경을 제공한다.
    - 총 4개의 항목으로 구성되어 있다. 좌측 끝 부분부터 명령어의 메모리 주소, 기계어 코드, 어셈블리 코드(기계어를 번역한 상태), 주석(코드에 대한 설명)
  - ### (2) Register 영역
    - 레지스터는 CPU 내부에 존재하는 다목적 저장 공간이다. 코드 동작 과정에서 필요한 값들을 임시로 저장하는 저장소와 같다. **주로 연산을 수행**하는 목적으로 사용된다.
    - 레지스터는 특수한 목적 및 일반적인 목적으로 자유롭게 사용할 수 있는 **범용 레지스터**, 한 가지 목적만을 위해 사용하는 **고정 레지스터**, 그리고 조건문과 분기문(JCC) 같은 코드의 흐름을 결정하는 데 사용되는 **상태 레지스터**로 구분할 수 있다.
  - ### (3) Memory Dump 영역
    - 프로세스 동작과정에서 읽고 쓰는 값들을 확인 및 수정할 수 있다.
    - **.data Section**의 값들이 존재한다. 문자열은 아스키 코드 값으로 변환되어 표현된다.
  - ### (4) Stack 영역
    - 스택은 임시 저장 공간이다. 데이터를 일시적으로 쌓아 두었다가 필요할 때에 꺼내서 사용할 수 있다.
    - 주로 함수의 인자 값과 EBP(호출한 함수의 Base Point), 그리고 EIP(호출한 함수에서 다음 실행할 명령어 주소) 등을 저장한다.
    - 쉽게 요약하면 '함수를 호출할 때, 필요한 정보를 전달하는 용도로 쓰인다.'라고 할 수 있다.

</br></br>

- ## IA -  32 Assembly
  - ## IA - 32 Register
    ![](https://images.velog.io/images/kmk9502/post/48dcb284-a178-4893-8052-2dbafc653643/IA%2032%20Register%20%EA%B5%AC%EC%84%B1.png)

    - ### 범용 레지스터
      - EAX, EBX, ECX, EDX, ESI, EDI
      - 범용 레지스터는 용도가 한정적이지 않고 다양한 목적으로 쓰일 수 있는 레지스터이다.
      - 범용 레지스터는 용도가 한정적이지 않지만, 특정 상황에서 특수한 역할을 수행할 수 있다.
        - **EAX**
          - 함수 return 값(결과 값)을 저장
        - **EBX**
          - Base, 특정 메모리를 가리키는 포인터로 사용
        - **ECX**
          - 카운터 코드에 사용 
            - Ex> for (int i = 1; i <= 10; i++)에서 i = ECX 
        - **EDX**
          - 곱셈, 나눗셈에 사용
        - **ESI**
          - 데이터를 복사하거나 조작할 때, 원본 데이터의 위치 주소가 저장된다.
        - **EDI**
          - 데이터를 복사할 때, 목적지의 주소가 저장된다.
    - ### 고정 레지스터
      - ESP, EBP, EIP
      - 고정 레지스터는 용도가 한정적인 레지스터이다.
        - **ESP**
          - 하나의 스택 프레임의 끝 지점 주소가 저장된다. 즉, 스택의 최상단을 가리키는 레지스터이다.
          - 프로세스가 스택의 값을 참조할 때 기준으로 삼는 값이다.
          - PUSH, POP 명령어에 따라서 ESP의 값이 4Byte씩 증가하거나 줄어든다.
          - SUB 명령어를 사용하면 스택의 공간이 확장된다.
            - Ex> SUB ESP, 8 => SUB 명령어로 스택을 8Byte만큼 확장
        - **EBP**
          - 하나의 스택 프레임의 시작 지점 주소가 저장된다.
          - 즉, 하나의 함수의 시작 지점 주소이다.
        - **EIP**
          - 다음에 실행해야 할 명령어의 메모리 주소를 저장하는 레지스터이다.
    - ### C언어의 함수 호출 규약
      - **함수 호출 규약**
        - 프로그램 흐름에 따라 여러 함수에 진입하고 빠져나올 때 **기존 데이터와 메모리 문맥을 일관성 있게 유지**하고, **다시 돌아올 곳을 기록하고 꺼내는 방법**

        - C언어 함수 호출 규약 순서
          - 1. 기존 함수(Caller)가 다른 함수를 호출한다.
          - 2. 호출된 함수(Callee)가 종료되고 기존 함수(Caller)로 돌아오기 위해 호출된 함수의 스택에 값이 저장되기 전 기존 함수의 EIP와 EBP를 저장한다.
          - 3. 호출한 함수와 호출된 함수의 스택 영역을 구분짓기 위해 호출된 함수는 새로운 EBP를 저장한다.
          - 4. 호출된 함수가 종료되고 스택이 정리된 후 기존 함수의 EBP 값을 스택에서 꺼내어 기존 함수의 EBP로 복구하고 다음 명령어 실행을 위해 EIP 값을 꺼내어 해당 주소로 이동한다.
          - **EBP는 어떻게 만들어질까?**
            - 기존 함수(Caller)의 EBP를 스택에 저장한 후 ESP 값이 호출된 함수(Callee)의 EBP 값이 된다.
            - 즉, 기존 함수의 EBP가 저장된 스택 주소가 Callee의 EBP가 된다.
            - Ex> C언어의 함수 호출 규약
             
                  PUSH  EBP         ; Caller의 EBP가 스택에 저장
                  MOV   EBP, ESP    ; Callee의 EBP 생성
                  PUSH  2
                  PUSH  1
                  CALL  00401000    
                  ADD   ESP, 8      ; 인자 값 정리
                  POP   EBP         ; Caller의 EBP 복구
                  RETN              ; Caller에서의 다음 실행 명령어 주소로 돌아가기

    - ### 상태 레지스터(Flags Register)
      - 행위에 대한 상태와 처리 결과를 나타내는 레지스터이다. 비교, 산술 연산을 포함하는 많은 명령어들이 플래그의 상태를 변화시키고 코드 동작 여부를 결정하기 위해 플래그 상태를 점검한다.

      |이름|설명|
      |:--|:---|
      |CF (Carry Flag)|부호 없는 수의 연산 결과, Overflow가 발생했을 때 1로 설정된다.</br>**부호 없는 수**란 C 코드에서 unsigned int와 같이 최상위 1bit를 부호를 표현하는 비트로 사용하지 않는 값을 뜻함|
      |OF(Overflow Flag)| 부호 있는 수의 연산 결과, Overflow가 발생했을 때 1로 설정된다.</br>**부호 있는 수**란 C 코드에서 일반적인 int와 같이 최상위 1bit를 부호를 표현하는 비트로 사용하는 값을 뜻함|
      |PF (Parity Flag)|코드 연산 결과, 최하위 1byte 에서 1의 값을 가지는 bit의 수가 짝수일 경우 1, 홀수일 경우 0으로 설정된다.</br>쉽게 말해서 연산 결과가 짝수면 1, 홀수면 0으로 설정된다.|
      |ZF (Zero Flag)| 산술이나 비교 연산의 결과를 나타낸다. </br>연산 결과가 0일 경우 1, 0이 아닐 경우 0으로 설정된다.
      |SF (Sign Flag, Negative Flag)|산술 연산의 결과 값에 대한 부호를 나타낸다.</br>즉, 최상위 1 bit 값을 나타낸다. </br>양수 = 0, 음수 = 1|
      |TF (Trap Flag, Debug Flag)| Single-step mode의 프로세서 연산을 허용한다.</br>디버거 프로그램의 경우 TF 플래그를 설정해서 한 번에 하나의 명령어만 실행시키도록 만들고 레지스터와 메모리 상에서 그 영향을 조사할 수 있게 하는 Flag이다.|
      ||

      </br></br>

- ## Srub 코드 이해
  - ### 정의
    - Stub 코드는 실행 파일을 만들 때 컴파일러가 집어넣는 코드이며, 실행 파일이 동작하는 데 필요한 정보를 얻어오는 코드로 구성되어 있다.
    - 컴파일 환경 (개발 도구 및 버전)에 따라 Stub 코드의 내용이 다르다.
  - ### 분석
    - 분석의 1차 목적은 제작자가 작성한 코드를 찾아서 그 기능을 파악하는 것이기 때문에, **Stub 코드는 넘기고 main() 함수를 빨리 찾아가는 것이 중요하다.**
  - ### Stub 코드에서 main() 함수 찾기
    - Stub 코드는 컴파일 환경에 따라 내용에 차이가 존재하지만, **프로그램이 동작하는 데 필요한 정보를 얻기 위한 코드**라는 것은 변하지 않는다.
    - 이러한 기능을 수행하기 위해 필요한 코드를 알고 있으면 분석할 때 main() 함수를 찾는 데 편하다.
    - Ex> 가장 기본적인 형태 - Visual Studio 6.0의 C++ 환경에서 컴파일 된 실행파일 Stub 코드
    ![](https://images.velog.io/images/kmk9502/post/08537d55-98b0-462e-8938-23e87c62b39c/stub%20%EC%BD%94%EB%93%9C%201.png)
    ![](https://images.velog.io/images/kmk9502/post/cf73b6d0-bf5d-4475-93c2-5eb11b3fb8fc/Stub%20%EC%BD%94%EB%93%9C_main%ED%95%A8%EC%88%98.png) 

      - **_heap_init() 호출**
        - 내부에서 **HeapCreate()** 호출
        - Heap 영역 초기화
      - **_ioinit() 호출**
        - Heap 영역 초기화 **실패시** 실행
        - 내부에서 **ExitProcess()** 호출
      - **GetCommandLineA() 호출**
        - 프로세스를 생성할 때, 검색한 명령 문자열에 대한 포인터 획득
      - **_crtGetEnvironmentStrings() 호출**
        - 내부에서 GetEnvironmentStrings() 호출
        - 현재 프로세스의 환경 변수를 획득
      - **GetModuleHandleA() 호출**
        - 현재 프로세스의 ImageBase 주소 획득
      - **main() 호출**
        - main() 함수 코드 시작
      - **exit() 호출**
        - 프로세스 종료