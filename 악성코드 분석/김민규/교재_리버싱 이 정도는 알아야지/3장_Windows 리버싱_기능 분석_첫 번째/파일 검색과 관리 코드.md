# 동작 확인 : Sample 05.exe

## Sample 05.exe 실행 전 상태

- ### Sample 05.exe가 존재하는 폴더
    ![](https://images.velog.io/images/kmk9502/post/c1fdb688-07a2-4be5-97b5-108b29029133/Sample%2005.exe%EA%B0%80%20%EC%A1%B4%EC%9E%AC%ED%95%98%EB%8A%94%20%ED%8F%B4%EB%8D%94.png)


## Sample 05.exe 실행 후 상태
- ### procmon으로 관찰한 파일의 변경
    ![](https://images.velog.io/images/kmk9502/post/fa46050d-5b87-4b0d-a80e-7445f5267727/Sample%2005.exe_procmon%EC%9C%BC%EB%A1%9C%20%EA%B4%80%EC%B0%B0.png)
   - ### 사용된 API
     - 파일을 열거나 생성하는 CreateFile() 
     - 파일의 내용을 복사하는 ReadFile()
     - 복사한 파일의 내용을 붙여넣는 WirteFile()
   - ### Sample 05.exe의 기능 예상
     - Sample 01.exe 파일을 %Temp% 경로에 Replicated Sample 01.exe 라는 이름으로 복제한다.
       
    ![](https://images.velog.io/images/kmk9502/post/ec1873a3-16ae-4957-9ea3-2815efb35310/Sample%2005.exe_%EA%B8%B0%EC%A1%B4%20Sample%2001.exe%20%ED%8C%8C%EC%9D%BC%20%EC%82%AD%EC%A0%9C.png) 

  - ### 실행 전 상태와 비교
    - 실행 전 존재했던 Sample 01.exe 파일이 삭제되었다. 
  - ### Sample 05.exe의 기능 예상
    - Sample 01.exe 파일을 복제한 뒤 삭제하는 기능이 존재할 것이다. 

- ### 해당 경로에 생성된 Sample 01.exe 복제 파일
    ![](https://images.velog.io/images/kmk9502/post/c2208385-953d-496b-84a6-9ebbd9712529/Sample%2005.exe_%ED%95%B4%EB%8B%B9%20%EA%B2%BD%EB%A1%9C%EC%97%90%20%EC%A1%B4%EC%9E%AC%ED%95%98%EB%8A%94%20%EB%B3%B5%EC%A0%9C%EB%90%9C%20Sample%2001.exe%20%ED%8C%8C%EC%9D%BC.png)

    - ### 결과 확인
      - 실제 %Temp% 경로에 복제된 Sample 01.exe 파일 확인

</br></br>



# 코드 학습 : Sample 05.exe

## 파일 복제 코드 기본 구성

## 1. Sample 01.exe 파일을 찾고 연다
![](https://images.velog.io/images/kmk9502/post/47475c59-9506-4b8b-b43a-929ee7e72559/Sample%2005.exe_%EB%94%94%EB%B2%84%EA%B1%B0_%ED%98%84%EC%9E%AC%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EA%B2%BD%EB%A1%9C%20%EA%B0%92%20%ED%99%95%EC%9D%B8%20%EB%B0%8F%20%EB%B3%B5%EC%A0%9C%ED%95%A0%20%ED%8C%8C%EC%9D%BC%20%EC%97%B4%EA%B8%B0.png)

```C
GetCurrentDirectory(MAX_PATH, lpBuffPath);

wsprintf(lpTargetPath, "%s%s", lpBuffPath, "\\Sample 01.exe");

hSourceFile = CreateFile(lpTargetPath, 
						GENERIC_READ, 
						0, NULL, 
						OPEN_EXISTING, 
						FILE_ATTRIBUTE_NORMAL, 
						NULL);
if(hSourceFile == INVALID_HANDLE_VALUE)
{
	return 0;
}
```
- ### GetCurrentDirectory() : 현재 프로세스에 대한 현재 디렉터리를 검색한다. 즉, Sample 05.exe가 위치한 경로 값을 알 수 있다. 
  - ### 인자 값
    - ### 첫 번째 인자
      - 현재 디렉터리 문자열에 대한 버퍼 길이 (TCHARs) 
    - ### 두 번째 인자
      - 현재 프로세스가 위치한 경로 값
        - Ex> C:\Users\IEUser\Desktop\Sample File

- ### wsprintf() : 형식화 된 데이터를 지정된 버퍼에 적는다.
    - ### 인자 값
      - ### 첫 번째 인자
        - 형식화 된 데이터가 저장되는 인자이다. 
      - ### 두 번째 인자
        - 첫 번째 인자에 저장될 데이터의 형식이다.
      - ### 나머지 인자 
        - 하나 이상의 변수를 선택적으로 넣을 수 있다. 
          - 세 번째 인자 값으로 Sample 05.exe는 **현재 프로세스의 경로**에서 복제할 대상인 Sample 01.exe 파일을 찾는다는 것을 알 수 있다. 즉, 현재 프로세스의 경로에 Sample 01.exe가 없다면 이 프로세스는 실패한다. 

- ### CreateFile() : 파일을 새로 만들거나 기존 파일을 열 수 있다. 
  - ### 인자 값
      - ### 첫 번째 인자
        - 생성 또는 열고자 하는 파일의 경로 값
        - wsprintf() 함수에서 만들어진 경로 값이다. 
        - `C:\Users\IEUser\Desktop\Sample File\Sample 01.exe` 라는 값이 저장되어 있다. 
    - ### 두 번째 인자
      - 해당 파일을 어떤 용도로 사용할 것인지에 대한 권한 정보
          - GENERIC_READ : 파일을 읽기 전용으로 연다. 
          - GENERIC_WRITE : 파일을 쓰기 전용으로 연다. 
          - (GENERIC_READ | GENERIC_WRITE) : 읽기와 쓰기 전용으로 연다.
          - GENERIC_DELETE : 파일 삭제 요청
    - ### 다섯 번째 인자
      - OPEN_EXISTING의 경우, 첫 번째 인자 값을 참조하여 파일(Sample 01.exe)이 존재하면 열도록 한다.  

</br></br>

## 2. Sample 01.exe의 데이터를 저장할 공간을 확보하고 복사한다

![](https://images.velog.io/images/kmk9502/post/58f3afb2-9dff-46a8-99d2-6dedce3b66ed/Sample%2005.exe_%ED%8C%8C%EC%9D%BC%20%EC%A0%80%EC%9E%A5%20%EA%B3%B5%EA%B0%84%20%ED%99%95%EB%B3%B4%20%EB%B0%8F%20%ED%8C%8C%EC%9D%BC%20%EB%B3%B5%EC%82%AC.png)

```C
dwFileSize = GetFileSize(hSourceFile, NULL);
	if(dwFileSize == 0xFFFFFFFF)
	{
		CloseHandle(hSourceFile);
		return 0;
	}
	
	lpBuffer = (char *)malloc(dwFileSize + 1); 
	if(lpBuffer == NULL)
	{
		CloseHandle(hSourceFile);
		return 0;
	}

	bResult = ReadFile(hSourceFile, lpBuffer, dwFileSize, &dwRead, NULL);
	if(!bResult)
	{
		free(lpBuffer);
		CloseHandle(hSourceFile);
		return 0;
	}
	CloseHandle(hSourceFile);
```

- ### GetFileSize() : lpTargetPath 인자가 가리키는 값. 즉, Sample 01.exe의 크기를 구한다.
  - ### 인자 값
    - ### 첫 번째 인자
      - Sample 01.exe의 핸들 값. 즉, 해당 API 함수가 운영체제로부터 Sample 01.exe의 정보를 사용할 수 있는 권한을 받는 인자 값이다.
- ### malloc() : Sample 01.exe 파일의 크기만큼 메모리 공간을 할당한다. 
  - ### 인자 값
    - ### 첫 번째 인자
      - GetFileSize()에서 도출된 파일 데이터 크기
- ### ReadFile() : Sample 01.exe의 데이터를 지정된 버퍼에 저장한다. (데이터 복사)
  - ### 인자 값
    - ### 첫 번째 인자
      - Sample 01.exe의 핸들 값이다.
    - ### 두 번째 인자
      - malloc()로부터 도출된 읽어올 데이터를 저장할 위치 주소이다.
    - ### 세 번째 인자
      - GetFileSize()로부터 도출된 읽어올 데이터의 크기이다.
- ### CloseHandle() : 획득한 핸들을 반환한다.
  - ### 인자 값
    - ### 첫 번째 인자
      - Sample 01.exe에 대한 핸들 값이다.

</br></br>

## 3. 원본 파일을 삭제하고 복제한 파일을 지정한 경로에 쓴다

![](https://images.velog.io/images/kmk9502/post/0fca8d0b-d8d1-46a7-a16a-adc1b1e69d9a/Sample%2005.exe_%EC%9B%90%EB%B3%B8%20%ED%8C%8C%EC%9D%BC%20%EC%82%AD%EC%A0%9C.png)
```C
bResult = DeleteFile(lpTargetPath);
	if(!bResult)
	{
		free(lpBuffer);
		return 0;
	}
```
- ### DeleteFile() : 지정한 파일을 삭제한다.
  - ### 인자 값
    - ### 첫 번째 인자
      - 삭제할 파일이 위치한 경로이다.
   
</br>

![](https://images.velog.io/images/kmk9502/post/a8d742d6-272b-4b7b-bac5-615152e8a3d1/Sample%2005.exe_%EB%B3%B5%EC%A0%9C%20%ED%8C%8C%EC%9D%BC%20%EC%93%B0%EA%B8%B0.png)
![](https://images.velog.io/images/kmk9502/post/0ddbfe5a-2c68-4330-850f-9952b0806028/Sample%2005.exe_%EB%B3%B5%EC%A0%9C%20%ED%8C%8C%EC%9D%BC%20%EC%93%B0%EA%B8%B02.png)
```C
GetTempPath(MAX_PATH, lpBuffPath);

wsprintf(lpTargetPath, "%s%s", lpBuffPath, "Replicated Sample 01.exe");
	
hDestFile = CreateFile(	lpTargetPath, 
						GENERIC_WRITE, 
						0, NULL, 
						CREATE_NEW, 
						FILE_ATTRIBUTE_NORMAL, 
						NULL);
if(hDestFile == INVALID_HANDLE_VALUE)
{
	free(lpBuffer);
	return 0;
}

bResult = WriteFile(hDestFile, lpBuffer, dwFileSize, &dwWrite, NULL);
if(!bResult)
{
	free(lpBuffer);
	CloseHandle(hDestFile);
	return 0;
}
CloseHandle(hDestFile);
```
- ### GetTempPath() : 임시 파일을 저장하는 Temp 디렉터리 경로를 찾아준다.
  - ### 인자 값
    - ### 첫 번째 인자
      - 문자열의 버퍼 크기이다.
    - ### 두 번째 인자
      - Temp 경로가 저장되는 인자이다.
        - `C:\Users\IEUser\AppData\Local\Temp` 라는 값이 저장되어 있다.
- ### wsprintf() : 형식화 된 데이터를 지정된 버퍼에 적는다.
- ### CreateFile() : 파일을 생성하거나 연다.
  - ### 인자 값
    - ### 첫 번째
      - `C:\Users\IEUser\AppData\Local\Temp\Replicated Sample 01.exe` 라는 경로가 저장되어 있다.
    - ### 두 번째
      - Replicated Sample 01.exe 파일에 Sample 01.exe의 데이터를 쓰기 위해서 쓰기 권한으로 파일을 열도록 한다.
    - ### 다섯 번째
      - 첫 번째 인자의 경로에 Replicated Sample 01.exe를 생성한다. 
- ### WriteFile() : 앞서 읽어 들인 파일(Sample 01.exe)의 데이터를 지정된 파일에 기록한다.
  - ### 인자 값
    - ### 첫 번째
      - 기록할 파일의 핸들 값이 저장된 인자이다.
    - ### 두 번째
      - 앞서 읽어 들인 파일의 데이터가 저장된 메모리 주소 값이 저장된 인자이다.
    - ### 세 번째
      - 앞서 읽어 들인 파일의 데이터 크기 값이 저장된 인자이다.
- ### CloseHandle() : 핸들 반환

</br></br>

## 코드 흐름 

- ### 요약
  - 1. 현재 프로세스가 위치한 경로 내의 Sample 01.exe을 찾는다.
  - 2. Sample 01.exe 파일을 연다(읽기 전용)
  - 3. Sample 01.exe 파일의 데이터를 저장할 공간을 확보한다.
  - 4. 확보한 공간에 Sample 01.exe 파일의 데이터를 복제한다.
  - 5. 원본 Sample 01.exe 파일을 삭제한다.
  - 6. 복제한 데이터를 붙여놓을 Temp 디렉터리의 경로를 얻는다.
  - 7. Temp 디렉터리에 Replicated Sample 01.exe라는 파일을 생성한다.
  - 8. 생성한 Replicated Sample 01.exe 파일에 복제한 Sample 01.exe 데이터를 입력한다.
  - 9. Replicated Sample 01.exe을 실행한다.

</br></br>

# 동작 확인 : Sample 05_AddFindFileCode.exe

## 실행 전 상태

- Sample 05.exe와 동일

## 실행 후 상태
- Sample 05.exe와 동일

</br></br>

# 코드 학습 : Sample 05_AddFindFileCode.exe

## 1. Sample 01.exe 파일 검색 기능 추가

```C
    GetCurrentDirectory(MAX_PATH, lpBuffPath);

  	wsprintf(lpFindPath, "%s\\%s", lpBuffPath, "*.*");

    hFind = FindFirstFile(lpFindPath, &FileData);
    if(hFind==INVALID_HANDLE_VALUE)
    {
      return 0;
    }

    do {
		if(strcmp(FileData.cFileName, "Sample 01.exe") == 0)
		{
			wsprintf(lpFindPath, "%s\\%s", lpBuffPath, FileData.cFileName);
            
            -Sample 01.exe 복제 코드 (Sample 05.exe와 비슷)-

        }
	} while(FindNextFile(hFind, &FileData)); 

	CloseHandle(hFind);
	
	return 1;
```

- ### wsprintf() : 형식화 된 데이터를 지정한 버퍼에 저장
  - ### 인자 값 
    - ### 네 번째 
      - `"*.*"`는 경로 내의 모든 파일을 가리킨다. </br>즉, 현재 프로세스가 위치한 디렉터리 내에 존재하는 모든 파일을 가리킨다.
- ### FindFirstFile() : 첫 번째 인자 값에 저장된 경로에서 하나의 파일을 찾는다.
  - ### 인자 값
    - ### 첫 번째
      - wsprintf()에서 만들어진 경로 값이 존재한다. 
    - ### 두 번째
      - &FileData는 **WIN32_FIND_DATA**라는 구조체를 담고 있다.
      - WIN32_FIND_DATA 구조체는 FindFirstFile()을 통해 얻은 파일에 대한 정보를 저장한다. 
        ```C++
        typedef struct _WIN32_FIND_DATAA {
        DWORD    dwFileAttributes;
        FILETIME ftCreationTime;
        FILETIME ftLastAccessTime;
        FILETIME ftLastWriteTime;
        DWORD    nFileSizeHigh;
        DWORD    nFileSizeLow;
        DWORD    dwReserved0;
        DWORD    dwReserved1;
        CHAR     cFileName[MAX_PATH];
        CHAR     cAlternateFileName[14];
        DWORD    dwFileType;
        DWORD    dwCreatorType;
        WORD     wFinderFlags;
        } WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA; 
        ```

        - ### cFileName[MAX_PATH] 
          - ### 기능
            -  FindFirstFile() 함수가 찾은 파일의 이름이 저장된다. 이 값을 찾고자 하는 파일인 `Sample 01.exe` 문자열과 비교한다. </br> 일치하지 않을 경우, `FindNextFile()`을 호출하여 다음 파일을 찾고 Sample 01.exe 문자열과 비교하여 일치할 때까지 반복한다. 

- ### FindNextFile() : 이전 파일이 조건에 맞지 않을 경우, 다음 파일을 찾는다. 
  - ### 인자 값
    - ### 첫 번째 
      - hFind는 FindFirstFile()의 핸들을 요청하는 값이다. 
    - ### 두 번째
      - &FileData 구조체이며, 다음 파일에 대한 정보를 기록하기 위해 인자 값으로 사용한다.

</br></br>

## 코드 흐름

- ### 요약
   - 1. 현재 프로세스가 위치한 경로 내의 모든 파일을 검색 대상으로 지정한다.
  - 2. 모든 파일 중 Sample 01.exe 문자열과 일치하는 파일을 찾는다.
  - 3. Sample 01.exe 파일을 연다(읽기 전용)
  - 4. Sample 01.exe 파일의 데이터를 저장할 공간을 확보한다.
  - 5. 확보한 공간에 Sample 01.exe 파일의 데이터를 복제한다.
  - 6. 원본 Sample 01.exe 파일을 삭제한다.
  - 7. 복제한 데이터를 붙여놓을 Temp 디렉터리의 경로를 얻는다.
  - 8. Temp 디렉터리에 Replicated Sample 01.exe라는 파일을 생성한다.
  - 9. 생성한 Replicated Sample 01.exe 파일에 복제한 Sample 01.exe 데이터를 입력한다.
  - 10. Replicated Sample 01.exe을 실행한다. 