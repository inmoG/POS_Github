# 파일 분석을 위한 구조적 접근방법

- ## 1단계
    - ### 분석의 목적을 구체화
      - 악성코드 분석 및 대응, 취약점 분석 및 대응, 시스템 오류 분석 및 대응 등
- ## 2단계
    - ### 프로그램 실행 흐름을 이해
      - `정적 분석`을 통해 파일 구조와 사용하는 함수, 그리고 코드와 사전 분석이 필요한 알고리즘 등을 파악
- ## 3단계
    - ### 중요한 함수들을 식별
      - 어떤 함수를 사용하는지 파악하면 해당 프로그램의 기능, 즉 목적을 대강 파악할 수 있다.
- ## 4단계
    - ### 함수 프로토타입 분석
        - 함수가 받는 인자값 및 함수의 결과값을 파악하고 그에 따른 분기의 흐름을 분석한다.
          - 도구 : IDA
- ## 5단계
    - ### 함수의 실제 기능 분석
        - 어셈블리 코드 해석 또는 디컴파일을 통해 함수의 기능, 즉 목적을 정확히 파악한다.
- ## 6단계
    - ### `동적 분석`으로 전체 프로그램에서 해당 함수의 기능을 파악
        - 레지스트리의 변화, 네트워크 패킷의 흐름, 프로세스의 변화 등 시스템에 미치는 영향을 파악
- ## 7단계
    - ### 분석 목적 달성 확인
        - 1. 악성코드가 시스템의 어느 부분에 영향을 미치는지 확인
        - 2. 악성코드가 시스템에 이미 영향을 주었다면 그 영향을 제거 </br> or 아직 감염되지 않은 시스템이라면 악성코드가 시스템에 영향을 주기 전에 예방조치를 취한다.
        - 3. 만약, 목적을 달성하지 못했다면 실수가 의심되는 단계로 돌아가 다시 분석

</br></br></br></br>

# 윈도우 API 함수

- ## API 함수란?
  - API는 `운영체제가 기본 제공하는` 특정 기능을 구현하는 함수이다.
    - Ex> CreateFileA()
  - dll 파일로 커널에 명령을 내려 운영체제와 밀접한 상호작용을 가능하게 한다.
  - 대부분 악성코드는 윈도우 플랫폼에서 동작하기 때문에 윈도우 API에 대한 지식은 필수이다.
  - ### 목적
    -  특정 기능을 구현할 때마다 많은 시간이 소요되는 길이가 긴 코드를 작성하는 번거로움을 덜기 위함 
       -  Ex> CreateFileA(); 
       -  https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea
    
# DLL

- ## DLL(Dynamic Link Libraries, 동적 링크 라이브러리)
  - ### DLL이 하는 일
    - `API 함수의 기능 구현`을 위한 정보를 전달 받고 커널에게 해당 기능의 구현을 요청한다.
     
        ![](https://images.velog.io/images/kmk9502/post/ada404ad-cc86-47ae-bb14-bd278fe3f002/DLL%20%EA%B5%AC%EC%A1%B0.png) 

    - `Kernel32.dll`, `Ntdll.dll`은 모든 프로세스에 기본으로 로드되는 dll이다. </br>이 두 dll은 함수 기능 구현을 위해 수많은 dll을 거쳐온 `결과를 최종적으로 커널에 전달`하고, `커널이 어플리케이션에게 서비스를 제공할 수 있도록` 하는 중간다리 역할을 담당한다.
      - ### Kernel32.dll
        - 부팅 시 로드되어 모든 프로세스에서 사용되고, 커널이 어플리케이션에 제공할 수 있는 서비스가 함수 형태로 존재하며, 프로세스, 스레드, 메모리 관리를 한다.
      - ### Ntdll.dll
        - Kernel32.dll과 함께 부팅 시 로드되어 모든 프로세스에 사용되며 커널 메모리 영역을 사용할 수 있도록 해주는 역할을 한다. 사실상 Kernel32.dll과 한 몸이나 다름 없다. 또한, 유저모드 어플리케이션들에게 커널 API를 연결하는 역할을 담당한다.
        - ### 네이티브 API
          - `네이티브 API는 Ntdll.dll에 포함`되어 있으며, 사용자 모드의 응용 프로그램에서 사용되는 API이다. 다른 윈도우 구성 요소들이 사용되기 힘들 때 사용되며, 주로 `시스템 부팅 시`나 kernel32.dll 같은 `윈도 API를 구현하는 용도로 쓰인다.` ntdll.dll의 엔트리 포인트는 LdrInitializeThunk이다. 대부분의 네이티브 API의 호출은 `ntoskrnl.exe에서 구현`되며, ntdll.dll에 의해서 사용자 모드로 보여진다. </br>`어떤 경우에는 사용자 모드에서 ntdll.dll 내부의 네이티브 API가 직접 호출되기도 한다.`
        - ### 대표적인 네이티브 API 함수
          - NtQuerySystemInformation : 시스템 정보 확인
          - NtQueryInformationProcess : 프로세스에 대한 정보
          - NtQueryInformationThread : 스레드에 대한 정보
          - NtQueryInformationFile : 파일에 대한 정보
          - NtQueryInformationKey : Key에 대한 정보
  - ### 요약
    - DLL : 커널에게 API 함수의 요청을 전달
    - Kernel : API 함수의 기능을 실제로 구현
  - ### 특징
    - 하나의 DLL 코드를 여러 프로세스가 공유할 수 있기 때문에 메모리 절약이 가능
     
         ![](https://images.velog.io/images/kmk9502/post/5de63ba9-775e-4b0f-84e8-4474abd37339/%EA%B3%B5%EC%9C%A0%EB%90%98%EB%8A%94%20DLL.png) 
         </br> 한 프로세스가 사용하는 DLL 코드를 여러 프로세스가 공유할 수 있다. 즉, 프로세스가 다른 프로세스의 DLL을 복사하고 가져와 사용할 수 있다. </br>
         이것의 의미는 DLL을 최초 한 번만 메모리에 적재하고 그 이후부터는 프로세스가 필요할 때만 dll을 매핑시켜주고, 프로세스가 DLL을 사용하지 않을 때는 DLL을 가져오지 않아 메모리 공간을 절약할 수 있다는 것이다.
  - ### DLL 종속성
    - 프로그램이나 DLL이 다른 DLL의 DLL 함수를 사용하면 종속성이 생성된다.</br>따라서 프로그램은 더 이상 독립적이지 않으며 종속성이 깨지면 프로그램에 문제가 발생한다.
      - Ex> 프로세스가 DLL 사용 -> DLL이 어떠한 기능 구현을 위해 다른 DLL 사용 -> 해당 DLL 또한 다른 DLL 사용 -> ... -> 커널에 기능 구현을 요청
  - ### DLL 인젝션
    - exe 파일의 각 프로세스는 독립적으로 존재하기 때문에 다른 프로세스로 삽입할 수 없다. </br> 그 대신 `다른 프로세스(SystemProcess 등)에 악성 exe 파일의 악성 dll을 삽입`하여 악의적인 기능을 다른 프로세스에서 실행할 수 있도록 하는 공격이 DLL 인젝션이다.