# 3가지 C++ 클래스 선언

- ## main() 함수 내 C++ 클래스 선언
- ## C++ 클래스 전역 선언
- ## C++ 클래스 동적 선언

</br></br>

# main() 함수 내 C++ 클래스 선언

클래스를 main()에서 선언했을 때 main()의 스택에 클래스의 멤버 변수가 저장된다. </br>
따라서 매우 큰 크기의 스택이 함수 내부에 할당되고 main()가 종료될 때 클래스도 정리된다.

```
push  ebp
mov   ebp, esp // 스택 베이스 포인트
sub   esp, 88h // 클래스의 멤버 변수의 크기만큼 스택 할당
~
mov   [ebp-88h], 1111h // 클래스의 첫 번째 멤버 변수에 0x1111 저장
```

</br></br>

# C++ 클래스 전역 선언

- 전역으로 선언된 클래스는 스택이나 Heap이 아닌 **.data** 섹션에 위치한다.
- 클래스를 전역으로 선언했을 때 포인터를 사용하지 않고 .data 섹션의 주소를 직접 지정해서 값을 저장한다.</br>
```
mov  dword_409908, 1111h // 클래스의 첫 번째 멤버 변수에 0x1111 저장
```

</br></br>

# C++ 클래스 동적 선언

- malloc이나 new 등의 동적 메모리(Heap) 할당 코드로 클래스를 동적으로 할당할 수 있다.

	```{.cpp}
	Employee *pkang; // Employee클래스의 포인터 변수 생성
	pkang = new Employee; //클래스를 동적으로 할당//포인터 변수 pkang에 Heap 영역에서의 클래스 포인터 저장
    ```
- 코드를 작성할 때 new 연산자에는 크기를 기록할 필요가 없지만, 내부적으로는 크기를 계산해서 집어넣는 작업이 일어난다.
	
	코드상 : 
    ```{.cpp}
    pkang = new Employee;
    ```
	어셈블리상 : 
    ```
    push  88h // 동적 메모리 할당 크기
	call  ??2@YAPAXIOZ // 동적 할당 주소 (Heap 영역 주소)
    ```
- 클래스의 멤버 변수에 값을 저장할 때는 Heap 영역 포인터에 오프셋(offset)을 더하여 위치를 지정하고 값을 저장한다.
	```
	mov  ecx, [ebp-4] // 클래스 포인터 저장
	mov  dword ptr [ecx], 1111h // 클래스 첫번째 멤버 변수에 0x1111 저장

	mov  eax, [ebp-4]
	mov  dword ptr [eax+84h], 100h // 클래스의 마지막 멤버 변수에 0x100 저장
    ```
- 포인터를 ecx에 저장하는 형태 : 스택에 저장된 클래스의 포인터를 담기 위해 mov를 사용한다.
	```
	mov  ecx, [ebp-4] // 해당 스택의 주소는 클래스의 포인터 주소값을 담고 있다.
	call sub_401030
    ```