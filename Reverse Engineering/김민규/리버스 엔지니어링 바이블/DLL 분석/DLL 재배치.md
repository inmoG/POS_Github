# DLL 재배치

## 재배치 섹션

- ### 존재 이유
  - PE 헤더에서는 DLL이 기준 주소인 0x10000000 에 로드되지 못했을 경우에 대비해 재배치 섹션이라는 것을 제공한다. 
- ### 기능
  - DLL이 기준 주소에 로드되지 못했을 경우 DLL의 Image Base를 변경하여 비어 있는 메모리 주소에 DLL을 넣는다. 
  - Image Base를 변경한 후, **주소 계산이 필요한 부분**은 재배치 섹션을 통해 모두 새로 배치해 준다.
  - 이 모든 과정은 운영체제에서 자체적으로 처리된다.

## 주소 계산이 필요한 부분

DLL의 Image Base가 변경되면 특정 메모리 주소값을 인자로 사용하는 코드도 변경될 수밖에 없다. </br>
왜냐하면, Image Base는 코드가 위치한 메모리 주소이고 이 주소가 변경된다는 것은 코드가 다른 곳으로 이사를 간다는 의미이기 때문이다. 즉, 코드에서 인자값으로 사용하는 메모리 주소도 같이 이동하여 기준 주소와는 다른 값이 되는 것이다.
</br></br>
아래는 Image Base가 바뀌었을 때 같이 바뀌는 부분이다.

- ### 1) push 문
 
        10012655   68 00900110   push dll.10019000

    10012655 번지에서 push의 인자로 10019000 번지에 있는 값을 스택에 넣었다. </br>
    현재 이미지 베이스가 0x10000000 이기 때문에 Image Base + offset 0x19000 해서 10019000이라는 값이 나오는 것이다. </br>
    그렇다면, 이 DLL의 Image Base가 바뀐다면 인자로 사용되는 주소값은 어떻게 변경될까?

        00BB2655   68 0090BB00   push dll.00BB9000

    push에 해당하는 옵코드인 68은 당연히 그대로이지만, 인자로 사용되는 주소값이 0x10019000 -> 0x00BB9000 으로 변경되었다. 이와 같이 이미지 베이스가 바뀌었으니 절대 주소도 바뀌는 것을 볼 수 있었다. 

- ### 2) mov reg, [mem]

        10012607   A1 C4F70110   mov eax, dword ptr ds:[1001F7C4]

        -> 00BB26D7   A1 C4F7BB00   mov eax, dword ptr ds:[BBF7C4]

    mov도 push 문과 유사하게 인자로 사용되는 주소가 Image Base가 변경되면서 같이 변경되는 것을 확인할 수 있다.

- ### 3) 점프문

        1001274E   FF25 98300110   jmp near dword ptr ds:[<&MSVCRT._vsnprin>]

        -> 00BB274E   FF25 9830BB00   jmp near dword ptr ds:[<&MSVCRT._vsnprin>]
    
    점프문은 인자로 메모리 주소값을 넣지 않는 명령어가 존재하므로 인자 보다는 옵코드를 찾아보는 것이 좋다. 옵코드는 리틀 인디언 형식으로 표현되어 있으며 `98300110 = 10013098` 이고, `9830BB00 = 00BB3098` 이다. 

## 재배치의 의미

- ### 어라, 이 주소에서 왜 다른 값이 나오지?
  - DLL은 위에서 설명한 것처럼 메모리에 로딩될 때마다 값이 달라질 수 있다. 예를 들어 어떤 문자열을 가리키는 주소가 DLL이 다시 로드될 때 전혀 다른 값을 가리킬 수도 있다.
  - 따라서 DLL의 재배치를 통해 이러한 특성이 있다는 사실을 파악하고 있어야 한다.