# 가상 메모리와 RVA

![](https://images.velog.io/images/kmk9502/post/d33a5076-473b-45a1-9810-53e218ae47d5/Inked%EC%A0%88%EB%8C%80%EC%A3%BC%EC%86%8C%EC%99%80%20%EC%83%81%EB%8C%80%EC%A3%BC%EC%86%8C%20%EC%84%A4%EB%AA%85_LI.jpg)

<그림으로 표현한 물리 메모리와 가상 메모리>

![](https://images.velog.io/images/kmk9502/post/2dcda5e0-0dbc-497d-97c1-df3a146ccc5e/%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B5%AC%EC%A1%B0_%EC%88%98%EC%A0%95.png)

<가상 메모리의 구조>

### 상대주소(RVA) 개념

상대주소 RVA는 **가상 메모리**에 위치한 Image Base부터의 상대주소을 의미한다.
- ### 가상 메모리 개념
  - ### User mode & Kernel mode
    - 가상 메모리는 유저 모드와 커널 모드로 나뉜다.
      - 윈도우 32bit의 경우 기본적으로 프로세스 별로 유저 모드 2GB, 커널 모드 2GB로 총 4GB로 구성된다.
    - 위 그림과 같이 프로세스별로 유저 영역 2GB, 커널 영역 2GB로 총 4GB의 독립된 메모리 공간을 가지고 있으며, 커널 영역 2GB는 모든 프로세스가 공유한다.
  - 가상 메모리는 물리 메모리에 올라가기 전에 프로세스들을 알맞게 다듬어 주는 곳이다. 
  - 프로세스를 다듬는 과정에서 주소가 변경될 수 있으니 ImageBase라는 기준에 따라 주소가 유동적으로 변할 수 있는 **상대주소** RVA를 사용한다. 
  - 상대주소를 사용하기 때문에 exe와 dll의 재배치가 가능하다. 
- ### 가상 메모리의 역할
  - 메모리 가상화를 통해 프로그램은 자신이 모든 메모리를 소유한 것처럼 **주소 값에 신경쓰지 않고** 메모리를 사용할 수 있다.
  - 한 프로세스에 오류가 발생하더라도 다른 프로세스의 메모리와 격리되어 있으므로 **안정성**을 높일 수 있다.
  - 각 가상 메모리에 대한 물리 메모리 매핑 과정은 윈도우 OS가 맡아서 한다.

## 물리 메모리 프로세스의 가상 메모리 접근

물리 메모리 상의 프로세스는 같은 메모리 상의 프로세스가 아닌 가상 메모리의 값에 접근하여 작업을 수행한다.

- ### WHY?
  - ### 물리 메모리의 특징
    - 물리 메모리에 위치한 프로세스는 연속적으로 메모리를 사용해야 하기 때문에 같은 물리 메모리에 있는 프로세스에서 값을 읽거나 쓸 수 없다.
    - 만일 같은 물리 메모리의 값에 접근하여 작업한다면 처리가 느려지고 복잡해지며 충돌이 일어날 수 있다.
- ### 가상 메모리의 등장
  - 물리 메모리의 문제를 해결하기 위해 **가상주소**, 즉 상대주소의 개념이 등장했다. 물리 메모리는 서로 간섭하지 못하니 가상 메모리를 만들고 가상주소에 있는 값에 접근하여 필요한 작업을 수행하기로 한 것이다.

---
## exe 재배치

exe 파일은 프로세스가 생성될 때 가장 먼저 메모리에 로딩되었기 때문에 재배치가 필요 없었다.
하지만 Windows Vista 이후부터 보안이 강화되어 ASLR(Address Soace Layou Randomization) 기능이 추가되었다. 그래서 exe를 실행할 때마다 메모리에서 ImageBase 값이 기본값 0x400000이 아니라 임의의 주소로 바뀐다.