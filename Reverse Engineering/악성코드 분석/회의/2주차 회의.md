# 2주차 회의

## 주제
- ### 2장 3-1 : Sample 02.exe 파일 분석 및 문제해결
- ### 2장 3-2 : Sample 03.exe 파일 분석 및 문제해결

</br></br>

# Sample 02.exe

## 분석
- ### 문제
  - 프로그램상의 오류로 'If Code!!' 문자열이 출력되지 않는다. 프로그램을 수정하여 출력하도록 하여라.
- ### 호출 함수 `GetLocalTime`
  - **msdn**을 통해 함수의 역할 및 SYSTEMTIME 구조체 학습
- ### if 조건문 발견
  - 어셈블리 명령어 CMP와 JNZ이 반복되는 3개의 구간을 발견
  - 2개의 값을 비교하여 조건을 만족할 시 다음 코드 실행하는 알고리즘이라는 사실을 밝혀냄
  - 어셈블리 언어로 표현된 if 조건문임을 학습
## 문제 해결
  - JMP 및 JCC 명령어, 조건 비교 값, 레지스터를 활용하여 문제를 해결

</br></br>

# Sample 03.exe

## 분석
- ### 문제
  - 프로그램상의 오류로 'For Code!!' 문자열 대신 10칸의 공백이 출력된다. 프로그램을 수정하여 올바르게 출력하도록 하여라.
- ### for 반복문 발견
  - CMP, JL 명령어를 사용하여 특정 조건을 만족할 때까지 특정 구간을 반복시키는 알고리즘 발견
  - 해당 구간이 어셈블리 언어로 표현된 for 반복문임을 학습
- ### 문제의 원인 분석
  - ### 호출 함수 `printf`의 인자 값 분석
    - **ECX**
      - ECX에 저장된 메모리 주소 값을 확인한 결과, For Code!! 문자열 바로 다음의 공백이 저장된 메모리 주소였음을 확인
      - 원인을 분석한 결과, [ESP+ESI+0x08]에서 ESI에 저장된 0x0A라는 값이 공백을 가리키는 원인임을 밝힘
    - **%c**
      - 출력 타입 중 하나로, C언어에서 문자열을 한 개의 문자씩 출력하는 기능을 담당
  - ### ESI 분석
    - **용도**
      - 1. 출력할 문자열의 메모리 위치(주소) 설정. 즉, 출력할 문자열의 시작점을 설정
      - 3. INC 명령어를 통해 한 번의 사이클을 돌 때마다 1씩 증가되며 for문의 반복횟수를 결정하고 동시에 출력 문자열을 한 개의 문자씩 출력하도록 함
 ## 문제 해결
  - **실패**
    - 과정 : [ESP+ESI+0x08]에서 ESI를 제거함으로써 For Code!!의 시작점 위치('F')을 ECX에 저장하는 것을 시도함
    - 결과 : 문자열의 첫 번째 문자인 'F'가 10번 반복됨
    - 원인 : ESI가 제거되어 `INC ESI`를 통해 For Code!!의 문자를 하나씩 출력할 수 없게 되자 For Code!!에서 F가 10번 반복되었다. 
  - **성공**
    - 과정 : ESI에 저장되는 0x0A 값을 0x0으로, CMP 명령어의 두번째 인자 값인 0x14를 0x0A로 치환한다.
    - 결과 : For Code!!가 정상적으로 출력된다.
    - 원인 : ESI의 값을 0으로 치환하여 For Code!!의 시작점 위치를 ECX에 저장하였고, `INC ESI`를 통해 For Code!!의 문자를 하나씩 출력할 수 있게 함. 또한, 반복횟수를 결정하는 `CMP ESI,14`를 `CMP ESI,0A`로 치환하여 'For Code!!' 뒤에 공백이 출력되지 않도록 함.