# 1장 리버싱 시작하기

## 리버싱이란?
    소프트웨어 공학의 한 분야로, 이미 만들어진 시스템을 역으로 추적하여 처음의 문서나 설계기법 등의 자료를 얻어내는 일

### 용어정리

- 운영체제 <br> 시스템 하드웨어를 관리할 뿐 아니라 응용 소프트웨어를 실행하기 위하여 하드웨어 추상화 플랫폼과 공통 서브시를 제공하는 시스템 소프트웨어
- 파일 시스템 <br> 컴퓨터에서 파일이나 자료를 쉽게 발견 및 접근할 수 있또록 보관 또는 조직하는 체제를 가리키는 말
- 메인 메모리 <br> 램이라는 저장 장치로 구성되어 있으며, 컴파일이 완료된 프로그램 코드가 올라가서 실행되는 영역
- 실행파일 <br> 단순히 데이터만 담고 있는 파일과 달리 코드화된 명령에 따라 지시된 작업을 수행하도록 하는 컴퓨터 파일
- 프로세스 <br> 실행중인 프로그램이라는 뜻으로 쓰임

### PE File Format

실행 파일을 어떻게 구성해야 할지 정해놓은 규칙

종류 : exe, sys, dll ...

### PE File Format
- PE Header : 파일을 실행시키기 위해 필요한 정보가 기록되어 있는 영역
- .text Section : 파일이 동작하는데 필요한 코드가 기록되어 있는 영역
- .data Section : 코드가 실행될 때 필요한 부가적인 정보가 기록되어 있는 영역

### Win32 API
Windows 운영체제에서 사용할 수 있게 만들어놓은 함수

### DLL
동적 연결 라이브러리(Dynamic Link Livrary)의 약어로 라이브러리이다.
윈도우 계열 운영체제에서 사용할 수 있다.

# 2장 Windows 리버싱
## 2-1 PE File format
### PE Header 
 사용자가 작성한 값이 아닌 코드를 컴파일 하는 과정에서 컴파일러가 알아서 작성하는 정보들

### 컴파일러가 PE 파일에 Header 정보를 기록하는 이유는?
    PE 파일을 만드는 것은 컴파일러지만 실행 주체는 운영체제이므로 PE 파일을 실행시키기 위해서 필요한 정보들을 모아주는 역할이기 때문에

## PE Header
![](https://images.velog.io/images/ktmf0704/post/f9ae10ce-df7a-4244-b1e4-74d0befb46ac/image.png)
- DOS Header <br> DOS와 호환성을 위해서 만들어 졌으며, 파일의 처음에 위치하고 0x40 크기를 가짐
- DOS Stub <br> 해당 파일이 MS-DOS에서 실행될 경우, 화면에 출력될 메시지와 코드가 기록되어 있다
             DOS Stub은 옵션이기 때문에 파일 실행에 영향이 없으며, 크기가 잃정하지 않고 없어도 되는 영역이다
- NT Header <br> 파일 실행에 필요한 전반적인 정보를 담고 있다 0xF8 크기를 가진다
- Section Headers <br> 각 섹션의 속성 정보를 담고 있다
(PE 파일 실행과 관련된 중요 정보들은 대부분 NT Header에 기록되어 있음)

## PE Header 구성도
![](https://images.velog.io/images/ktmf0704/post/790a86e4-5ea2-4bea-8158-70dcd34c19c0/%EC%BA%A1%EC%B2%986.PNG)

### Dos Header
![](https://images.velog.io/images/ktmf0704/post/1d6915c8-b711-4917-b37a-34444461cdbd/%EC%BA%A1%EC%B2%98.PNG)
- DOS signature : 실행 파일이라는 표식 "MZ(0x5A4D)"의 값을 갖는다
- NT header offset : NT 헤더의 시작 지점에 대한 정보를 담고 있는다

### NT Header
![](https://images.velog.io/images/ktmf0704/post/8140705c-b286-4120-8c21-57e6e23fc865/%EC%BA%A1%EC%B2%982.PNG)
- Signature : 올바른 PE 파일인지 확인하는 용도

![](https://images.velog.io/images/ktmf0704/post/2855395a-e87a-4bb2-9172-43900a7ba29f/%EC%BA%A1%EC%B2%983.PNG)
- FILE HEADER : 파일의 physical 정보를 담고 있는 구조체

    - Machine : 파일이 실행될 UPU 타입 정보를 담고 있다.
    - 섹션 개수 : 파일의 섹션 개수 정보를 담고 있다.
    - OH size : Optional Header 크기 값을 가지고 있다 <br> 일반적으로 0xE0 값을 가진다
    - 파일 특성 : 파일의 속성 정보를 가지고 있다 <br> 이 값으로 EXE와 DLL의 구분이 가능하다

![](https://images.velog.io/images/ktmf0704/post/692b07b4-b36b-4962-a51d-a570bd148509/%EC%BA%A1%EC%B2%984.PNG)
- OPTIONAL HEADER : 파일의 logical 정보를 담고 있는 구조체

    - Magic : Optional Header가 IMAGE_OPTIONAL_HEADER32 구조체인 경우 0x010B, IMAGE_OPTIONAL_HEADER64 구조체인 경우 0x020B 값을 가진다
    - Address of EntryPoint : 파일의 코드 시작 지점에 대한 RVA 값을 가지고 있다
    - Image Base : 파일 데이터가 메모리에 올라갈 때, 기준이 되는 주소 값을 가지고 있다 <br> 기본적으로 EXE는 0x00400000, DLL은 0x10000000의 값을 가진다
    - Section Alignment / File Aligenment : PE 파일의 Body 부분은 섹션으로 나누어져 있다 <br> 파일에서 섹션의 최소 단위를 나타내는 것이 FileAlignment 이고 메모리에서 섹션의 최소 단위를 나타내는 것이 SectionAlignment 이다
    - Magor Version
    - Size of memory : 메모리에 올라간 파일 데이터의 크기 값을 나타낸다
    - Size of Headers : DOS Header, NT Header, Seection Header를 합친 총 크기 값을 나타낸다
    - Data Directories 개수 : Data Directory의 개수를 나타낸다.
    - Data Directories 정보 : Data Directories는 Data Directories 개수 필드의 개수만큼 활성화된다 <br> 일반적으로 0x10개의 정보가 기록되어 있지만 필수는 아니다

FILE Header와 Optional Header는 각각 하나의 구조체이다

### Section Header
![](https://images.velog.io/images/ktmf0704/post/7d8642c8-a706-4b91-8d17-82b35f406acc/%EC%BA%A1%EC%B2%985.PNG)

- VirtualSize : 메모리에서 섹션이 차지하는 크기
- RVA(VirtualAddress) : 메모리에서 섹션의 시작 주소
- SizeOfRawData : 파일에서 섹션이 차지하는 크기
- OffsetToRawData : 파일에서 섹션의 시작 주소
- Characteristics : 섹션의 속성 정보를 담고 있음

### IAT와 EAT
- IAT(Import Address Table) : DLL이 제공하는 함수들 중에서 사용하는 것들에 대한 정보를 기술해 놓은 테이블
- EAT(Export Address Table) : DLL 자신이 서비스하는 함수에 대한 정보를 기술해 놓은 테이블

## 2-2 리버싱을 위한 준비

### OllyDBG 기본 화면 구성

![](https://images.velog.io/images/ktmf0704/post/700a4835-bc57-4a6a-8cdc-c924c4b6a613/1.PNG)
- Diassemble 영역 <br> 기계어를 보기 쉽게 어셈블리어로 번역해서 띄워주고 어셈블리 코드를 실행 또는 중지할 수 있도록 환경을 제공
- 레지스터 영역 <br> CPU 내부에 존재하는 다목적 저장 공간
- 메모리 영역 <br> User 메모리 영역에서 할당된 공간 중, 사용자가 원하는 영역에 기록되어 있는 값을 확인할 수 있도록 환경을 제공
- 스택 영역 <br> 임시 저장 공간 <br> 데이터를 일시적으로 겹쳐 쌓아 두었다가 필요할 때에 꺼내서 사용할 수 있음 <br> 레지스터와 달리 요소의 개수가 제한적이지 않고 길이가 가변적이다

### 어셈블리어란?
    기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어
    기계어를 사람이 인식할 수 있는 언어로 정의해놓은 것

### 범용 레지스터
- EAX(Extended Accumulator Register) <br> 함수 호출에 대한 결과 값을 저장하는 용도로 사용
- ECX(Extended Counter Register) <br> 코드의 반복이 필요한 경우, 반복 카운터 값이 저장
- ESI(Extended Source Index) <br> 데이터를 복사하거나 조작할 때, 원본 데이터의 위치 주소가 저장된다
- EDI(Extended Destination Index) <br> 데이터를 복사할 때, 목적지의 주소가 저장된다
- ESP(Extended Stack Pointer) <br> 하나의 스택 프레임의 끝 지점 주소가 저장된다
- EBP(Extended Base Pointer) <br> 하나의 스택 프레임의 시작 지점 주소가 저장된다

### 범용 레지스터
- 말 그대로 다음에 실행해야 할 명령어의 메모리 주소를 저장하는 레지스터

### 세그먼트 레지스터
세그먼트는 프로그램에 정의된 특정 영역(코드, 데이터, 스택)이며, 각 크기는 16비트이다
- CS(Code Segment) <br> 실행 가능한 명령어가 존재하는 세그먼트의 오프셋이 저장된다
- DS(Data Segment) <br> 프로그램에서 사용되는 데이터가 존재하는 세그먼트의 오프셋이 저장된다
- SS(Stack Segment) <br> 스택이 존재하는 세그먼트의 오프셋이 저장된다
- ES(Extra Segment) <br> 추가 레지스터로 주로 문자 데이터의 주소를 지정하는데 사용한다
- FS(Data Segment) <br> 추가 레지스터로 TEB(Thread Environment Block) 주소를 지정하는데 사용한다

### 플래그 레지스터
행위에 대한 상태와 처리 결과를 나타내는 레지스터 <br> 비교, 산술 연산을 포함하는 많은 명령어들이 플래그의 상태를 변화시키고 코드 동작 여부를 결정하기 위해 플래그 상태를 점검한다
- CF(Carry Flag) <br> 부호 없는 수의 연산 결과, Overflow가 발생했을 때 1로 설정된다.
- OF(Overflow Flag) <br> 부호 있는 수의 연산 결과, Overflow가 발생했을 때 1로 설정된다.
- PF(Parity Flag) <br> 코드 연산 결과, 최하위 1byte에서 1의 값ㅇ르 가지는 bit의 수가 짝수일 경우 1, 홀수일 경우 0으로 설정된다
- ZF(Zero Flag) <br> 산술이나 비교 연산의 결과를 나타낸다 <br>연산 결과가 0일 경우 1,0이 아닐경우 0으로 설정된다
- SF(Sign Flag, Negative Flag) <br> 산술 연산의 결과 값에 대한 부호를 나타낸다 <br> (양수 = 0, 음수 = 1)
- TF(Trap Flag, Debug Flag) <br> Single-Step mode의 프로세서 연산을 허용한다 <br> 디버거 프로그램의 경우 TF프래그를 설정해서 한 번에 하나의 명령어만 실행시키도록 만들고 레지스터와 메모리상에서 그 영향을 조사할 수 있게 한다

## 2-4 실행압축

1. 압축되어 있는 데이터를 읽어와서 압축 해제 후 메모리에 기록한다.
2. 압축 해제가 완료되면 CALL이나 JMP 주소를 반복한다.
3. IAT를 복구한다
4. OEP를 복구한다

![](https://images.velog.io/images/ktmf0704/post/8ed37571-3111-438d-ac35-d3252511665b/%EC%BA%A1%EC%B2%98.PNG)

