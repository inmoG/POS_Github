# WEB2_HTTP
1990년 Web이 세상에 나왔을때 Web은 크게 네가지 요소. 
웹페이지를 만드는 컴퓨터 언어 HTML, 원하는 웹페이지에 방문할 수 있도록 도와주는 주소 체계인 URL URI, 웹페이지를 주고 받는 소프트웨어인 Web browser, Web server, 둘이 통신을 할 때 사용하는 통신 규칙인 HTTP이 있다.<br/>

약자는 'HyperTextTransfer Protocol'<br/><br/>

HTTP가 발전하면서 웹을 넘어 인터넷의 근간이 되었다. HTTP는 Request, Response를 나타낸다. Request Header - browser가 server에게 요청한 것, 사용자가 요청한 정보를 텍스트 정보로 만들어서 Web server에게 대신 물어봐주는 것. Web server는 가지고 있는 정보를 보내주면서 응답 헤더를 만들어주는 기계이다. browser는 응답한 정보를 화면에 적당히 그려주는 프로그램이라고 보충적으로 이야기한다.<br/><br/>

Request Header 첫번째 행을 요청행이라 부른다.
1.html - 우리가 Web server에게 요청하는 정보가 무엇인가.
http 1.1 -  Web browser가 사용하고있는, 사용할수있는 http버전이 1.1이다. user-Agent - Web browser의 다른 표현.
Macintosh - 내 컴퓨터 정보.
Response Header 첫번째 행을 status라 부른다.
Response Header 첫번째 행은 version, status code, phrase 순서.<br/><br/>

https의 S는 SECURE의 약자로 안전이라는 뜻. http뒤에 s가 없다면 조심해야 한다.
이미 저장된 파일을 읽어서 성능을 향상시키는 기법이 cache. 내용이 갱신되었을 때 Web browser는 모른다.<br/><br/>

이전에 처리했던 기록들을 Web site와 browser가 기억하고 있도록 해주는 기술이 쿠키다.
프록시는 browser와 server사이에 중계 서버를 둘 수 있다. 캐시를 대신 해주거나 공격을 막아주거나 사용자의 요청을 여러 서비스로 분산해준다.





# Domain Name System
인터넷에 연결된 컴퓨터 하나하나를 호스트라고 한다. 호스트와 호스트가 서로 통신하기 위해서는 주소 필요, 이를 위해 쓰는 게 아이피 주소.<br/><br/>
아이피 주소는 기억하기가 너무 어려움. 그래서 Jon Postel과 Paul Mockapetris에 의해서 Domain Name System이 만들어졌다. 이것의 핵심은 DNS 서버. 수많은 아이피 주소의 도메인 이름이 저장된다.<br/><br/>

두 대의 컴퓨터가 인터넷을 통해 통신을 하려면 반드시 갖추어야 하는 것, 아이피 주소. 좀 더 포괄적으로 Host라고 부름. 네트워크에 연결되어있는 컴퓨터구나 라고 생각하면 됨. hosts를 이용해 DNS를 쓰지 않고도 통신 가능.<br/><br/>

DNS 이전의 상황 - 하나의 닷컴의 주소로 들어오면 아이피로 모든 컴퓨터가 접속을  할 수 있으면 얼마나 좋을까 생각했다. 닷컴 이름은 유지하면서 아이피 주소는 바꾸는 유연함도 기대 가능. 이걸 위해서는 신뢰할 수 있는 무언가가 필요했어서  Stanford Reserch Institute가 host를 관리했다. 영업시간에 전화해서 요청하는 방식으로. 하지만 한계에 도달함. 그래서 위의 사람들이 DNS를 만들었다.<br/><br/>

도메인 네임과 아이피 주소를 기억한대. 그리고 요청하는 컴퓨터에게 기억한 걸 전달한다. 그러기 위해서는 받는 컴퓨터가 도메인 서버의 아이피를 알고 있어야 한다. 통신사들은 컴퓨터가 도메인을 물어봤을 때 사용할 도메인 네임 서버의 아이피를 등록하는 매커니즘을 갖고있음. 연결하는 순간 컴퓨터의 DNS 서버가 정해진다. 수천 수만대의 DNS 서버로 전세계인들이 아이피를 기억하지 않고도 인터넷을 쉽게 사용할 수 있도록 돕고 있다.<br/><br/>

도메인은 sub, second-level, top-level, root라고 불리는 것으로 나뉘어져 있다. 이 각각의 부분에는 각각을 담당하는 독자적인 서버 컴퓨터가 존재한다. 이것들이 DNS 서버. 상위 서버가 하위 서버에 대해 알고 있어야 한다. 건너서 알지는 못하고 직속 하위 서버만 알 수 있다. <br/><br/>
DNS는 기술적보단 행정적이다. 이것을 자동화하는 기술이 뒷받침 되고 있다.<br/><br/>

비영리단체 ICANN 전세계 아이피 주소 관리, 루트 네임 서버들에 대한 관리자. Registry(등록소) 탑레벨 도메인 관리. 네임 서버에다가 실제로 등록자의 등록 작업을 대행해주는 업체가 등록대행자. 등록자가 등록대행자에게 이름.닷컴이라는 도메인을 쓰고 싶다고 이야기하면 등록대행자가 등록소에 등록을 한다. 그러면 등록소가 소유권을 주고 계약한다.<br/><br/>

DNS와 관련한 정보 수집하는 방법. 닷컴의 아이피는 무엇인가 알아내는 데에 쓰는 대표적인 도구 nslookup, dig. 터미널에 nslookup 이름.com 치면 뜬다.
한 번 알려주면 기억하고 있던 아이피를 돌려주는 걸 cache라고 함.<br/><br/>
(freenom.com 많이 쓰이는 등록대행자.)<br/><br/>

특정 도메인 네임에 대한 정보를 저장하는데 그 하나하나를 DNS Record라고 한다. A type Record는 어떤 도메인 주소에 대한 아이피 주소를 매핑시키는 거에서 연결 시키는 것. CNAME Record는 일종의 별명을 지어주는 것이다. 도메인에 대한 별명으로 주소를 정해주는 것. A type은 도메인에 대한 아이피 주소, CNAME은 도메인에 대한 또 다른 도메인을 지정하는 것이다.





# Home server
인터넷 위에 있는 컴퓨터가 통신을 하기 위해서는 아이피 주소가 필요하다. 그래서 IPv4라는 인터넷 통신 규칙을 만든다. 여기서 사용하는 아이피 주소는 42억개의 주소 표현이 가능하다. 하지만 인터넷이 발달하기 시작하며 아이피 주소가 부족해졌다. <br/><br/>

가장 근본적인 해결책은 주소의 형식을 완전 새롭게 바꾸는 것. 새로운 인터넷 통신 규칙인 IPv6에서는 완전히 새로운 주소 체계를 도입했다. 주소를 바꾸는 건 쉽지 않은 일이라 IPv4와 IPv6를 같이 써야 했다. 그 노력이 공유기이다. <br/><br/>

통신사에 받아온 선을 WAN에 꽂으면 아이피 주소가 공유기의 것이 된다. 각각의 장치들은 LAN에 연결한다. 다 같은 네트워크로 묶여있는 것을 지역 네트워크라고 한다. WAN은 인터넷이라고 하는 광역 네트워크에 묶여있다. 연결되면 장치들이 각각 아이피를 부여받는다. 지역 네트워크 안에서만 쓸 수 있는 아이피 주소를 사설 아이피 주소라고 부른다. <br/><br/>

장치가 어딘가에 접속할 때 신호를 보낸다. 공유기가 요청을 받고 선을 타고 외부로 보낸다. 그런데 내부 아이피는 외부로 못 빼기 때문에 Network Address Translation가 아이피를 바꾼다. <br/><br/>

장치 중 컴퓨터 하나를 클라이언트가 아닌 서버로 사용하고 싶을 때 어떻게 해야 하는지. 접속이 들어왔을 때 여러 장치 중 누가 응답할 것인지 알기 위해 port forwarding 사용한다.<br/><br/>

포트 번호 0~1023까지는 Well-known port로 약속된 포트다. <br/><br/>

공유기로 접속이 들어오면 장치 중 하나로 전달해준다. <br/><br/>

port forwarding이라고 하는 것을 통해 라우터로 들어온 포트 번호가 뭐냐에 따라 내부 네트워크에 있는 특정한 머신에 특정 포트로 요청을 forwarding 할 수 있다. <br/><br/>

Dynamic 아이피 주소 - 통신사 (ISP) 계약을 맺어서 집에 케이블을 꽂으면 아이피 주소가 생긴다. 컴퓨터에 서버를 깔고 아이피 주소를 알준다. 그런데 아이피 주소가 부족해 유동 아이피를 사용한다. 컴퓨터에 서버를 깔지만 아이피는 유동이라 아이피가 바뀌게 된다. <br/><br/>

Static 아이피 주소 - 돈 더 주고 고정된 아이피를 사용한다. <br/><br/>

통신규칙 DHCP - 각자 컴퓨터에 케이블을 꽂거나 무선으로 연결하면 복잡한 정보들이 자동으로 세팅된다. 그것이 가능하기 위해서는 DHCP 서버가 필요하다. 인터넷을 사용하는 기계들에게는 DHCP 클라이언트가 기본적으로 깔려있다. 통신 부품들은 부품마다 공장에서 기록된 고유한 식별자를 갖고 있다. 식별자로 DHCP 서버에게 아이피 주소를 요청하면 DHCP 서버가 아이피 주소를 빌려준다. DHCP 서버는 누가 어떤 아이피를 빌려갔는지 기억하고 있다. <br/><br/>

NAS - 네트워크를 통해 사용하는 저장 장치이다. 





# 웹 기술 기초편
world wide web (www, 실무에서는 따따따라고 표현)
웹이라는 것은 다수의 네트워크가 모여서 형성된 공간으로 거미줄같다고 해서 웹이라고 부른다.<br/>
웹은 유럽 입자 물리학 연구원 팀 버너스 리 박사에 의해 탄생하였으며 멀리 떨어진 동료들과 지식을 공유하기 위해 만들어졌다.<br/><br/>

초기의 웹은 단순히 텍스트로 구성이 되어 있었다.<br/>
 Hyper text - 초월된 문서라는 뜻으로 하나의 문서에서 다른 문서로 이동할 수 있는 기술이다. HTTP, HTML에도 사용되는 말. 이때는 글을 등록, 수정, 삭제 등 참여하는 행위는 못하고 일방적으로 정보 제공만 받는 형태였다. 웹 1.0 시대.<br/><br/>

웹 2.0 시대에 접어들며 폭발적으로 성장. 이용자의 참여와 공유가 가능해졌다. 시대의 흐름에 발맞춰 나간 싸이월드, 네이버 지식인이 대표적이다. 또 개인에 맞춰 기업들이 영향을 받았고 전자상거래 기업까지 등장하였다.<br/><br/>

웹 브라우저는 웹을 사용할 수 있는 시작점으로 웹 서버의 통신을 통해 요청과 응답을 주고 받고 HTML, JAVASCRIPT, CSS 등의 클라이언트 언어를 해석하여 사용자에게 GUI를 제공해준다. 현재는 마이크로 소프트의 '인터넷 익스플로러', 구글의 '크롬', 애플의 '사파리' 모질라 재단의 '파이어 폭스', 그리고 '오페라' 등이 많이 사용되고 있다.<br/><br/>

웹은 클라이언트(사용자, 웹 브라우저), 서버(웹 서버, WAS) 구조로 되어 있다. 웹 서버에 따라 PHP, JSP(JAVA), ASP등 사용되는 언어가 다르다. 클라이언트는 서비스를 이용하는 대상으로 최초에 서비스 요청을 하게 된다. 그리고 서버는 서비스를 제공하는 대상으로 클라이언트 측으로부터 요청을 받게 되면 그에 대해 서비스를 제공하여 준다.<br/><br/>

웹을 구성하는 3대 요소로 HTML, HTTP, URL이 있다. HTTF는 웹 서버와 웹 클라이언트간에 통신을 할 수 있도록 지원을 해주며, URL은 웹 클라이언트가 웹 서버로 자원을 요청할 수 있게 해준다. HTML은 웹 클라이언트가 웹 서버로 URL을 통한 자원요청 후 HTML이 담긴 응답을 받으며, 웹 브라우저가 이를 해석하여 사용자에게 구조화된 인터페이스를 출력시켜준다. 이 3대 요소는 웹의 핵심적인 기술이다. <br/><br/>

URL은 통합 자원 지시자로 인터넷의 리소스를 가리키는 표준 명칭으로 서버의 자원을 요청할 때 사용된다. 인터넷 상의 모든 리소스를 요청할 수 있으며, 우리가 흔히 알소있는 HTTP 뿐만 아니라 FTP, SMTP 관련된 자료 요청도 가능하다.<br/><br/>

| URL 구조분석 |  |
|:----------|:----------:|----------:|
| http | 스키마 부분으로 사용될 프로토콜이 명시되어 있는 부분이다. |
| www.test.co.kr | 서버 주소인 호스트 부분으로 자원을 가진 컴퓨터의 위치가 명시되어 있다. 뒤에 포트 번호가 있어야 하나, 기본 80포트는 생략이 가능하다. |
| images | 자원이 존재하는 디렉터리다. |
| background.png |요청할 자원의 이름이다.|

<br/><br/>

| URL 예약문자 (메타문자) |  |
|:----------|:----------:|----------:|
| ? | 파라미터가 시작된다는 것을 알려준다. |
|  = | 파라미터 값 대입. |
| & | 다음 파라미터 식별자이다. |
| + | 공백. |

<br/>
URL 인코딩 - URL에서 문자를 표현하는 방법으로 데이터 전송 상에 손실을 막기 위해서 인코딩을 사용한다. 웹 브라우저를 사용할 경우 자동으로 해준다.<br/><br/>


| URL 인코딩 |  |
|:----------|:----------:|----------:|
| & | %26 |
| % | %25 |
| + | %2B |
| 공백 | %20 |
| = | %3D |
| # | %23 |
| ' | %27 |
| ? | %3F |

<br/>
HTTP는 하이퍼텍스트 문서를 전송하기 위해 사용되는 프로토콜. 하이퍼텍스트 문서는 HTML 파일이다.<br/>

OSI 7 Layer 이것은 교육에 적합한 모델로 실제로는 TCP/IP 계층 모델을 표준으로 하고 있다. 대부분의 네트워크 통신은 TCP/IP 기반 통신을 근간으로 한다. 이때 통신을 위한 중요한 정보가 있는데 IP와 port이다. IP를 통해 물리적 호스트 대상을 찾으며, port를 통해 논리적 대상을 찾는다. HTTP 프로토콜의 연결 관리 방식은 크게 비지속 연결과 지속 연결 두 가지로 나뉜다. 비지속 연결은 초기 HTTP에서 사용하였다. 초기엔 단순히 문서만 주고 받았기 때문에 지속할 필요가 없었다.<br/><br/>

요청 메세지의 시작줄은 요청 라인으로 메소드, 요청 URL, 버전이 들어가며 메세지 헤더는 요청의 속성과 추가 정보들이 포함되어 있다. 응답 메세지의 시작줄은 상태 라인으로 버전, 상태 코드, 응답 문구가 들어가며 메세지 헤더는 응답의 속성과 추가 정보들이 포함되어 있다.<br/><br/>

HTTP 메소드에는 여러가지가 있으나, GET/POST 메소드가 일반적으로 웹 통신시 가장 많이 사용되는 메소드이다. GET 방식은 URL에서 데이터가 실리고 POST 방식은 바디에 값이 실린다. POST 방식에 컨텐츠 타입이 가장 중요하고 정상적으로 해석이 되려면 꼭 나와줘야 한다. GET은 단순히 받기 위해 POST는 서버 측에 액션을 하기 위해 사용한다.<br/><br/>

상태 코드 - 서버는 요청에 대한 상세 결과를 알려준다.<br/><br/>


| 상태 코드 |  |
|:----------|:----------:|----------:|
| 1xx | 정보 |
| 2xx | 성공 |
| 3xx | 리다이렉션 |
| 4xx | 클라이언트 에러 |
| 5xx | 서버 에러 |
<br/>

| 대표적 예시 |  ||
|:----------|:----------:|----------:|
| 200 | OK | 정상적으로 처리됨 |
| 302 | Found |다른 페이지로 이동|
| 304 | Not Modified |수정되지 않음|
| 400 | Bad Request |클라이언트 요청 에러|
| 403 | Forbidden |접근 권한 없음|
| 404 | Not Found |존재하지 않음|
| 500 | Internal Server Error |서버측 에러|


<br/><br/>
HTTP 메세지 헤더는 메세지를 구성하는 요소로 클라이언트와 서버가 무엇을 할지 결정하고 처리하기 위한 정보들이 들어있으며, 요청 메세지와 응답 메세지에는 반드시 메세지 헤더가 포함되어 있다.
예전과 다르게 상태 유지 및 관리가 필요하게 되었고 이를 위해서는 쿠키가 사용된다. 쿠키를 통해 사용자 식별 및 세션 유지를 통해 클라이언트와 서버 간의 상태 관리를 한다. 쿠키의 종류는 지속 쿠키, 세션 쿠키가 있으며, 일반적으로 말하는 쿠키는 지속 쿠키, 세션은 세션 쿠키이다.<br/><br/>

서버에서 클라이언트로 쿠키 발급 시 Set-Cookie 헤더에 의해 클라이언트 쿠키 값이 세팅되며, 해당 사이트 접근 시마다 클라이언트는 쿠키에 의해 세팅된 값을 Cookie 헤더에 세팅하여 요청 메세지를 전달한다.
지속 쿠키는 웹 서버에서 발급 시 클라이언트 하드 디스크에 텍스트 형태로 저장이 되며, 클라이언트 PC 사용자들은 해당 쿠키 정보를 열람할 수 있다.<br/><br/>

 세션 쿠키는 웹 서버에서 발급 시 클라이언트 웹 브라우저 캐시에 저장되며, 정상적으로 로그인 시 웹 어플리케이션 서버는 서버 측에 해당 세션에 대한 정보를 저장한다. 이때 서버에서 세션을 저장하는 방법으로 메모리, 파일 시스템, 데이터베이스에 저장하는 방법들이 있으며, 일반적으로 메모리에 저장해둔다.<br/>

세션쿠키를 사용하면 보안 담당자, 개발자들이 편하지만, 대규모 웹 서비스의 경우 수많은 사용자들의 세션을 관리하기에는 서버에 엄청난 부하를 가져온다. 이러한 이유로 서버에 부담이 낮은 지속 쿠키 사용을 많이 선호한다. 웹 서비스 규모와 인프라 구성에 알맞게 사용해야 한다.<br/><br/>

일반적인 웹 아키텍처는 클라이언트, 웹 서버, 데이터베이스의 형태로 되어 있으며, 영역 별로 프론트 엔트와 백 엔드로 나뉜다. 그리고 오늘 날의 웹 개발자들은 크게 프론트 엔드 개발자와 백 엔드 개발자, 이 둘을 전부 하는 풀 스택 개발자로 나뉜다.<br/>

클라이언트 측에서 사용자가 웹 브라우저를 통해 사이트 접속을 하게 된다. 그러면 웹 브라우저에서는 가장 먼저 도메인에 따른 IP 변환 작업을 한다. 이후 요청 메세지를 제작한다. 응답 메세지를 받으면 이를 해석 후 바디에 있는 데이터인 HTML 코드를 웹 브라우저가 해석하여 사용자에게 인터페이스를 제공하게 된다.<br/><br/>

오늘날의 웹 사이트 구조는 이전의 구조에 비해 큰 변화를 가지고 왔다. 바로 Ajax라는 기술로써 페이지 동기화 필요없이 서버에 요청/응답을 받아 페이지 재구성(렌더링)이 가능해졌다. 기존 웹 패러다임을 전환하는 기술로써 현재 많이 사용되고 있다. 또한 백 엔드 측에 부하율을 낮출 수 있기 때문에 트래픽이 많이 발생되는 웹 사이트의 경우 Ajax 기술을 적극적으로 사용하고 있다.<br/>

Ajax기반의 웹 사이트라고 해서 진단 방법이 달라지는 것은 아니다. 요청과 응답이 하는 행위는 동일하기 때문이다. 그러나 이 과정에서 컨텐츠 타입이 달라 당황하는 경우가 있는데 JAVASCRIPT를 분석 후 알맞게 데이터 변조를 하면 된다.<br/><br/>

웹 서버는 클라이언트 요청에 따른 웹 서비스를 제공한다. JAVA Web Application 환경의 경우 웹 서버와 웹 어플리케이션 서버를 분리하여 웹 서버는 정적인 컨텐츠 자원 제공을 담당하며, 웹 어플리케이션 서버는 동적인 컨텐츠 자원 제공을 담당한다. 이를 통해 보다 효율적이며 유연한 서비스 제공을 목표로 한다.
클라이언트 측에서 웹 서버에 요청 메세지를 보내면 웹 서버는 이를 요청된 자원 유/무를 검토하여 클라이언트 측에 응답 메세지를 실어 보낸다.<br/><br/>

우리가 URL로 서버에 자원을 요청하는 것들은 웹 서버에 어떠한 설정된 경로로 인해 가능하며, 이렇게 웹 서버에서 바라보는 경로를 웹 디렉터리, 웹 루트, 도큐먼트 루트 등으로 부른다. 이 설정 파일은 파일 다운로드/업로드 취약점 공격 시 많이 활용된다.
웹 서버와 웹 어플리케이션 서버를 분리하는 이유는 웹 서버는 정적 자원 처리에 대해 최적화가 되어 있고, 웹 어플리케이션 서버는 동적 차원 처리에 최적화가 되어 있다. 업무 분담을 하여 자원 처리에 대한 효율성을 극대화시킨다.<br/><br/>

데이터베이스는 동적인 컨텐츠를 제공하기 위해 데이터를 저장해두는 저장소로 일반적으로 사용자 정보, 상품 정보, 커뮤니티 정보 등 수많은 정보들이 저장되는 곳으로 게시판에 글을 쓰고 보고, 회원가입을 하여 로그인을 할 수 있는 이유도 데이터베이스 때문이다.<br/><br/>

웹 구조는 크게 Server Side와 Client Side로 나눌 수 있으며, 웹 클라이언트에서 해석되는 스크립트를 Client-Side Script라고 하며, 웹 어플리케이션 서버에서 해석되는 스크립트를 Server-Side Script라고 한다.<br/><br/>

Client-Side Script 기반 보안 검증이 안전하지 않은 이유 - 클라이언트 측에서 보안 검증 절차가 구현되어 있다 하더라도 서버 측 보안 검증 로직을 반드시 구현해야 한다. 이유는 웹 프록시 도구와 개발자 도구를 통해 Client-Side Script 조작 및 값 변조가 가능하기 때문에 사실상 검증 자체가 무의미하다. 뿐만 아니라 input 태그의 hidden 타입의 전송도 웹 프록시 도구 혹은 개발자 도구로 확인할 수 있으며, 변조가 가능하기 때문에 해당 값을 신뢰해서는 안된다.