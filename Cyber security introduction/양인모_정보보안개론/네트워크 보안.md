# 네트워크 보안

## 서비스 거부 공격(Dos)

### Boink, Bonk, TearDrop 공격

오류 제어 로직을 악용하는 시스템 자원 고갈 공격이다.

시퀀스 넘버 기반의 오류 제어 방식을 사용해 특정 연결 유효성을 제어한다.
TCP 패킷 안에는 각 패킷이 데이터 어느 부분을 포함하고 있는지를 표시하기 위해 시퀀스 넘버가 기록되는데, 이러한 공격들은 시스템 패킷 재전송과 재조합에 과부하가 걸리도록 시퀀스 넘버를 속인다.

### Land 공격

패킷을 전송할 때 출발지 IP 주소와 목적지 IP 주소값을 똑같이 만들어서 공격 대상에게 보낸다. 이때 조작된 IP주소값은 공격 대상 IP주소이다.
이 공격법은 동시 사용자 수를 점유하고 CPU부하를 올려서 시스템을 다운시킨다.

### ping of Death 공격

ping 명령의 패킷을 최대한 길게 해 공격 대상에게 보낸다. 공격 대상은 대량의 작은 패킷을 수신해 네트워크가 마비된다.
ping of Death 공격을 막으려면 내부 네트워크에 들어오지 못하도록 방화벽에서 ICMP 프로토콜을 차단한다.

### SYN Flooding 공격

3-way handshake를 악용한 공격으로 존재하지 않는 클라이언트가 서버별로 한정되어 있는 접속 가능한 공간에 접속한 것처럼 속여, 다른 사용자가 서버의 서비스를 제공받지 못하게 한다. 서버는 클라이언트가 ACK 패킷을 보내올 때까지 SYN Received 상태로 일정 시간을 기다려야 하고, 그동안 공격자는 가상의 클라이언트로 위조한 SYN 패킷을 수없이 만들어 서버에 보냄으로써 서버의 가용 동시 접속자 수를 모두 SYN Received 상태로 만들어 사용자가 서버의 서비스를 제공받지 못하게 한다.
공격이 끝난 후 서버가 SYN Received 상태에서 자동으로 벗어나는 시간이 지나면 시스템은 곧 회복된다. 따라서 SYN Received 대기시간을 줄이면 공격을 막을 수 있다.

### HTTP GET Flooding 공격

3-way handshake 과정을 통해 정상 접속을 한 뒤, 특정 페이지를 HTTP의 GET Method를 사용해 무한대로 실행한다. 공격 패킷을 수신하는 웹 서버는 정상적인 TCP 세션과 함께 정상적으로 보이는 HTTP GET 요청을 지속적으로 요청해, 시스템에 과부하가 걸린다.
지정된 웹 페이지를 지속적으로 요청하는 공격이므로 웹 방화벽에 특정 HTTP 요청 패턴을 차단한다.

### HTTP CC 공격

HTTP 1.1 버전의 Cache-Control 헤더 옵션은 자주 변경되는 데이터에 대해 새롭게 HTTP 요청 및 응답을 요구하기 위해 캐시 기능을 사용하지 않게 할 수 있다. 이를 응용해 `Cache-Control:no-store, must-revalidate`옵션을 사용하면 웹 서버는 캐시를 사용하지 않고 응답해야 해 웹서비스 부하가 증가한다. 지정된 웹 페이지를 지속적으로 요청하는 공격이므로 웹 방화벽에 특정 HTTP 요청 패턴을 차단한다.

### 동적 HTTP Request Flooding 공격

`HTTP GET Flooding, HTTP CC` 차단 기법을 우회하기 위해 요청 페이지를 변경해가며 요청하는 공격 기법이다.

### Smurf 공격

ICMP패킷과 네트워크에 존재하는 시스템들을 이용하는 DoS공격이다. 다이렉트 브로드 캐스트를 악용하는 공격으로 ICMP Request를 받은 네트워크는 패킷의 위조된 시작 IP주소로 ICMP Request Reply를 다시 보낸다. 결국 공격 대상은 수많은 ICMP Reply를 받게 되고 Ping of Death 공격처럼 수많은 패킷이 시스템을 과부하 상태로 만든다. 라우터에서 다이렉트 브로드캐스트를 막으면 공격을 방어할 수 있다.

### 분산 서비스 거부 공격(DDoS)

공격자가 한 지점에서 Dos공격을 수행하는 형태를 넘어 광범위한 네트워크를 이용하여 다수의 공격 지점에서 동시에 한 곳을 공격하도록 하는 형태의 서비스 거부 공격이다. 공격 형태는 아래와 같다.

1. PC에서 전파 가능한 형태의 악성코드 생성
2. DDoS 공격을 위해 사전에 공격 대상과 스케줄을 정해 악성코드에 추가한다.
3. 명령을 내리면 악성코드에 감염된 봇넷(좀비 PC 네트워크)이 공격을 시행한다.

## 스니핑 공격

### 스니핑 원리

네트워크에 접속하는 모든 시스템은 설정된 IP와 MAC주소를 가진다. 통신할 때 NIC는 이 두 가지 정보를 가지고 자신의 랜 카드에 들어오는 주소 값을 인식하고 자신의 버퍼에 저장할 지 결정한다. 만약 자신의 주소와 일치하지 않는 패킷은 무시한다. 스니핑을 수행하는 해커는 모든 패킷을 수집하려 한다. 따라서 2계층과 3계층 필터링을 해제하는 랜 카드 모드인 프러미스큐어스 모드로 설정한다.

#### 스니퍼 탐지

2계층은 mac주소로 통신해 pc는 자신 mac주소를 가진 패킷이 아니면 무시한다. 하지만 스니핑 pc는 자신에게 온 패킷 뿐만 아니라 같은 네트워크 대역의 모든 pc 패킷을 받다보니 존재하지 않는 mac주소의 패킷도 받게된다. mac주소가 존재하면 해당 주소를 가진 pc는 패킷을 받겠지만 없는 m주소여서 아무도 패킷을 못받는다. 이 원리를 응용해 ping, arp, dns를 이용해 스니퍼 사용여부를 탐지 가능하다. 그리고 arpwatch 툴을 사용하면 ARP 스푸핑을 탐지할 수 있다.

## 스푸핑 공격

### ARP 스푸핑 공격

MAC주소를 속이는 공격으로 LAN대역에서 통신중인 서버와 클라이언트 IP주소에 대한 MAC주소를 공격자의 MAC주소로 속임으로써, 클라이언트에서 서버로 가는 패킷이나, 서버에서 클라이언트로 가는 패킷을 공격자에게 보내 랜의 통신 흐름을 왜곡시킨다. MAC 주소를 고정시켜 공격을 막을 수 있지만 시스템이 재부팅될 때마다 고정해야하는 문제점이 있다.

### IP 스푸핑 공격

IP주소를 속이는 것으로, 트러스트 관계(신뢰관계)가 맺어져 있는 서버와 클라이언트를 확인한 후 클라이언트에 서비스 거부 공격을 해 연결을 끊고, 공격자가 클라이언트 IP주소를 확보해 실제 클라이언트처럼 **아이디와 패스워드 없이** 서버에 접근하는 공격이다. 유닉스 계열은 트러스트 인증법을 사용하고 윈도우는 Active Directory를 사용한다. 트러스트를 이용한 접속은 인증이 IP를 통해서만 일어나기 때문에 공격자가 해당 IP를 사용해서 접속하면 스니핑을 통해서 패스워드를 알아낼 필요가 없다. 공격형태는 아래와 같다.

1. 트러스트 접속 중인 클라이언트에 DoS 공격 실행
2. 트러스트 연결이 끊어진다.
3. 공격자가 클라이언트의 IP를 가로채 서버에 접속한다.

트러스트 설정이 불가피한 경우를 제외하고는 트러스트를 사용하지 말아야 하며 취약한 패스워드로 설정하면 안된다. 취약한 계정 하나로 인해 트러스트로 연결된 서버 모두가 위험해질 수 있다.

### ICMP 리다이렉트 공격

스니핑 시스템을 네트워크에 존재하는 또 다른 라우터로 알려 패킷의 흐름을 바꾸는 공격이다. `A >> 라우터A >> 인터넷` 네트워크 흐름을 `A >> 라우터B(공격자 PC) >> 라우터 A >> 인터넷`으로 변경해 스니핑 하는 공격이다.

### DNS 스푸핑 공격

실제 DNS 서버보다 빨리 공격 대상에게 DNS Response 패킷을 보내, 공격 대상이 잘못된 IP주소로 웹 접속을 하도록 유도하는 공격이다.

- DNS 동작 원리

  1. DNS 서버에게 접속하고자 하는 도메인 주소의 IP주소를 물어본다.
  2. DNS 서버가 해당 도메인 이름에 대한 IP주소를 클라이언트에게 보낸다.
  3. 클라이언트는 받은 IP주소로 웹 서버에 접속한다.

DNS 패킷은 UDP 패킷이므로 세션이 존재하지 않으며 먼저 도착한 패킷을 신뢰하고 다음에 도착한 패킷은 버린다.

- DNS 스푸핑 공격 구성

  1. DNS서버로 DNS Query패킷을 보내는 것을 확인해야 한다. 스위칭 환경일 경우에는 클라이언트가 보내는 패킷을 스니핑 해야하므로 ARP 스푸핑과 같은 선행작업이 필요하다.
  2. 공격자는 로컬에 존재해 지리적으로 DNS 서버보다 가깝다. 따라서 DNS 서버가 DNS Response 패킷을 보내기 전에 클라이언트에게 위조된 DNS Response 패킷을 보내야 한다.
  3. 클라이언트는 위조된 Response 패킷의 웹 서버 IP주소를 사용해 서버에 접속한다. DNS 서버가 보낸 DNS Response 패킷은 버린다.

- 대응방안

  윈도우와 유닉스 모두 URL에 대한 IP를 확인할 때 처음부터 DNS Query를 보내는 것은 아니다. 먼저 시스템 메모리 정보를 확인하고 hosts 파일에 등록된 정보를 확인한다. hosts파일은 서버의 URL과 IP정보가 등록되어있다. 모든 서버 IP를 동록할 수 없으니 중요 서버의 URL과 IP를 등록해 공격을 막는다.

- hosts 파일 위치

  Windows : C:\Windows\System32\drivers\etc\hosts

  linux : /etc/hosts

### Session Hijacking

세션 가로채기 공격으로 세션이란 "사용자와 컴퓨터 또는 두 대의 컴퓨터 간의 연결이 활성화된 상태 즉 로그인 된 상태"를 의미한다.
TCP는 클라이언트와 서버 간 통신을 할 때 패킷의 연속성을 보장하기 위해 클라이언트와 서버에 각각 시퀀스 넘버를 사용한다. 시퀀스 넘버가 잘못되면 이를 바로 잡기 위한 작업을 한다. TCP 세션 하이재킹은 서버와 클라이언트에 각각 잘못된 시퀀스 넘버를 위조해서 연결된 세션에 혼란을 줘 자신이 끼어들어가는 방식을 사용한다.

- Session Hijacking 공격 구성

  1. ARP 스푸핑 등을 통해 클라이언트와 서버 사이의 통신 패킷이 공격자를 지나가지 않게 한다.
  2. 공격자는 서버에 클라이언트 주소로 연결을 재설정하기 위한 RST 패킷을 보낸다. 서버는 해당 패킷을 받고, 클라이언트의 시퀀스 넘버가 재설정 된 것으로 판단하고, 다시 3-way handshake를 시도한다.
  3. 공격자는 클라이언트 대신 연결되어 있던 TCP 연결을 그대로 물려받는다.

3단계를 거쳐 아이디와 패스워드 입력 없이 세션을 획득한다. 세션 하이재킹을 막으려면 텔넷과 같은 취약한 프로토콜을 이용하면 안된다.
SSH와 같이 암호화 프로토콜을 사용해 서버에 접속해야 한다.
